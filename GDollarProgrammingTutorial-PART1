================================================================
 

By    Jemin  Information   Technology  (C)  2017
==================================================================================

GDollar Technology   focused   for  datastuctures  ,  compiler  design 
and  Software  Development
============================================================

GDollar Technology is a modern Programming Language consists of JAVA OOPS, Behave
like C/C++ ,C#  OOPS,GDollar Advanced  OOPS Networking, RUN and compile at same time,it  is  used in Software Development , cloud computing ,
Research, and ,Advanced OOPs.
It is used in case of  constructing  datastructures,etc.

SYNTAX FOR GDollar (.Gdollar) (beautiful syntax)
---------------------------------------------------------------
<GDollar>

<%
<! GDollar OOPS Logic !>

public void GDollar-Main()
{

}
?>

public void GDollar-Main()
note: This should be saved in filename.Gdollar
----

How GDollar Technology Works  for  GDollar-LIB?

At  first  .Gdollar  is compiled by GDOLLARc compiler
GDollarc   convert  to  intermediate  code  called as   filename.C$.  and  it  calls 
GDollarv.4  compiler.
After that GDOLLARv.4  compiles the  intermediate  code
 using  GDollar  java to  bytecode format(class files )and  it  use
GDollar-JAVA Runtime   to run the Program. and  after  that  GDollar  output
is  stored   in  .wl file. 

How   GDollar  Technology  works   for  GDollar-MAIN(CWE)?

When  Gdollar  compiler   compilers   a    Gdollar  program  it
generates  .dll and  .exe  file  for  futhure  use.

Why  you  use   Gdollar  technology? what   is the  major  advantage  of  Gdollar?
Since    after  compiling  Gdollar   code  it  generates  
intermediate  encode  (.C$)  files.  That   hacker  or  any  body  
cannot  understood  the  code.  ie)  Hacker  cannot   take
the  orginal  source  code.
GDollar  technology  prevents   code  stealing  using this  concept.


==============================================================================
GDollar -PROGRAMMING-TUTORIAL   -GDOLLARPART1
--------------------------------------------------
Written By
wilmix jemin j
==============================================================================
UNIT -1
--------
INTRODUCTION
------------
Why GDollar?
-------------

GDollar  is   a  Programming  Langauge   and  it  used    for  constructing   advanced   datastructures, complex  datastructures,  and  focused  on compiler  design   and  it   is  mostly  by  universities,colleges,companies,industries.
it  is   invented    by   wilmix jemin  in  JAVA ,C/C++,C#    P.L.

What   are  Gdollar  Modules? 
Gdollar   has   7  modules   they  are....
a) GDollar -LIB 
b)  GDollar -Advanced OOPS (CWE -Editor)

c)  GDollar-cdollar (for  software  development)
d)  GDollarv.4 (intermediate  encoder)
e) JSLASH  (autogenerated  technology  with  in  few  seconds)
f) GDollar - CJAVA
g) GDollar -JSTAR  (focused  on   Remote  WebDesign  using  mobiles  and  wallet)
 used  only  for  security   webdesign work without  internet connection.

SYNTAX-1 (used only for  creating  libraries - .Gdollar)
------------------------------------------------------------


<GDollar>
<USE> packages;

<%

<! OOPS Logic and  datastructures !>

%>


 ?>








PRINT STATEMENT OF GDollar .Gdollar
------------------------------------------------
Print Statement of GDollar - .Gdollar
-------------------------------------------------
Print.Println(String ,<DataTypes>);
where DataTypes is {int,char,String,Double,float)
This will print space followed by concatenation of String and
datatypes input when you apply \n.
This solves everytime when user wish to concat a String with
datatype every time.
simillary
Print.printf(String ,<DataTypes>);
This will be same to above Print statement but
it will not print space when you apply \n also.

Program1.Gdollar
-----------------
<GDollar>
<USE> <CJAVA>.util.*;
<%
class Program1
{
public  Shared void  LIB( )
{
int i;
Print.Println("\nList of Technologies in year ","2016 ");
LL1 list = <NEW> LL1();
String i1="weew";
Print.Println("wilmix",i1);
Print.Println("Hiram is going","today");
Print.printf("Hiram Age is =","45 ");
Print.Println("Hiram is working ","in Abc Bank\n");
Print.Println(" \njemin","is going");
<TS> ar2 = <NEW> <TS>();
ar2.add("100");
ar2.add("22");
Print.printf("jeminjhjhjh",ar2.StringConvert());
Print.Println("no: 2/782 ,ds street,california-2322",ar2.StringConvert());
}
}
%>
?>
Notice what happens?
Compile and run the GDollar Program in bash shell using the
command
GDOLLARC Program1.Gdollar
Output:
.
*************************************************************************************
********
Sun Sep 20 14:38:19 GMT+00:00 2015*GDollar: List of Technologies in year 2016 0 C 1
GDollar 2 GDollar 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCER
wilmix weewHiram is going todayHiram Age is = 45 Hiram is working in Abc Bank jemin is
goingjeminjhjhjh [100, 22]
no: 2/782 ,ds street,california-2322 [100, 22]


How GDollar is formed ? What are its Advantages Over Native language JAVA Programming?
--------------------------------------------------------------------------------------------------------------
GDollar is formed in C++ OOPS concepts..
JAVA borrowed C++ OOPS concepts but
GDollar borrowed C++ OOPS concepts and JAVA oops and it has
Attractive syntax ; Plus in-build functions
for Program and it is responsible for creating
libraries (.wl). JAVA has attained the Programming
standards, But GDollar attains combination of C Technology
and JAVA Technology advantages.
GDollar Generates .wl class files
but JAVA Generated .class files.
GDollar Has Advanced OOPS than JAVA 1.8.






==================================================================================
                                      UNIT-2 :GDollar ADVANCED CONCEPTS
==============================================================================
ADVANCED OOPS CONCEPTS
--------------------------------------------
Example -3:
------------
Write a Program to print two String and add String 100 to
ArrayList.
and create a DataStructure for Linked List and Technologies for year
2016  is C, GDollar ,GDollar,CHDOLLAR, JDOLLAR,JSTAR, JSAUCER.
And add Those in Userdefined LinkedList. 
Program :abc.Gdollar
-------------------

<GDollar>
<USE> <CJAVA>.util.*;
<%
class LL1
{
private LL1 nextNode = null;
private String datum = null;
public LL1()
{
LL1 list = <NEW> LL1("0 C");
list.add("1 GDollar");
list.add("2 GDollar");
list.add("3 CHDOLLAR");
list.add("4 JDOLLAR");
list.add("5 JSTAR");
list.add("6 JSAUCER");
for (int i = 0; i NOT= list.size(); i = i + 1)
{
GDollar.WriteLine(""+list.get(i).StringConvert());
}
}
public LL1(String datum)
{
<SUPER>();
<IS>.datum = datum;
}
public void add(String datum)
{
if (nextNode NOT= null)
{
nextNode.add(datum);
return;
}
nextNode = <NEW> LL1(datum);
}
public String get(int i)
{
if (i == 0)
return datum;
return nextNode.get(i - 1);
}
public int size()
{
if (nextNode == null)
return 1;
return nextNode.size() + 1;
}
}
class abc
{
public void GDollar-Main() throws  <EXE>
{
int i;
GDollar.WriteLine("\nList of Technologies in year "+"2016 ");
LL1 list = <NEW> LL1();
String i1="weew";
GDollar.WriteLine("wilmix"+i1);
GDollar.WriteLine(" \njemin"+"is going");
<AList> ar2 = <NEW> <AList>();
ar2.add("100");
;
GDollar.WriteLine("jeminjhjhjh"+ar2.StringConvert());
}
}
%>
?>
Note : LinkedList1 is the unwanted keyword
-------
so GDollar did not accept it.
What will be the Output when you run using ?
>GDOLLARc abc.GDollar
Output:
------
Compiling ....
*************************************************************************************
********
Sun Sep 20 14:46:18 GMT+00:00 2015*GDollar: List of Technologies in year 2016
0 C 1 GDollar 2 GDollar 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCERwilmix weew jemin is goingList
of Technologies in year 2016
0 C 1 GDollar 2 GDollar 3 CHDOLLAR 4 JDOLLAR 5 JSTAR 6 JSAUCERjeminjhjhjh [100, 22]
Error: <table bgcolor=green>OUTPUT=Compling GDollar filesGDOLLAR VERSION 1.3 Copy
Right 2015 all rights reserved
Created by Jemin Information Technology ,wilmix jemin Bad token: < on row 2 and column 1
Process failed during translation. no Errors in GDollar program
Example-4:
-----------
Write a Program to add 1 lakh Natural integers using arraylist
using   GDollar  LIB.
Program2:
---------
<GDollar>
<USE> <CJAVA>.util.*;
<%
public class Program2 
{
public  Shared void  LIB( )

{
<AList> ar= <NEW> <AList> ();
for (int i=0;i<=100000;i++)
ar.add(i);
}
}
%>
?>
==================================================================================
                                   
                                         GDollar  ADVANCED  DATA STRUCTURES   THEORY

=================================================================================
GDollarArrays

SYNTAX for GDOLLARArrays:
--------------------------------------
CARRAYS list1 = new CARRAYS(string);
to add any collection objects to array use
add (String) functions and to Display those
objects use list1.Display();
Any class that use CARRAYS you should extends Array in class...


TREEOFARRAY
---------------------
Write a Program to add 1 lakh Natural integers incremented by 10 using arraylist
and add the arraylist objects to TreeOfARRAY
what happens when you compile and execute the given the below program?

SYNTAX for TreeofArray:
--------------------------------------
TreeArray <name> = new TreeArray(String);
<name>.add(elements);
where elements may be string or collections....
 It store other collection objects and stores huge amount of data
in tree format.
LISTOFARRAY
---------------------
SYNTAX for List of Array:
--------------------------------------
LArray <name> = new LArray(string);
<name>.add(elements);
The elements may be string or collection elements.

Ans: It store other collection objects and stores huge amount of data
in tree format and sorts the elements in descending order and allow to insert the
element in to middle of list. This means act like combination of Set and Linked List , and Tree....


==================================================================================

UNIT 3: MISC ,Fundametals of GDollar, Keywords,Operators,loops,Datatypes,Inner class, OOPS
concepts of GDollar ,and collections
==================================================================================

GDollar OUTPUT STATEMENT
----------------------------------------------
GDollar.WriteLine(" "+" ");
It is used for printing the output followed by line.
We had to add + operator to concatenate the outputs.....
String
------------
String is represented by <Str> notation.
a) <Str> <strname> = new <Str> ();
This statement is used to create an object...
b) <Str> <strname> = value;
But this Statement will not create an object...
but it stores the value...
the differences between
a) if ( s1==s2)
== means it is used to compare the values...
b) if s1.EQ(s2)
EQ means EQUALS is used to compare objects..

GDollar COLLECTIONS
------------------------------------
Why we use collections in our software development?
Because for various projects we will use various kinds of
datastructures that's why collections are focused.

Q: What are the Important concepts of Software Development?

ARRAYLIST
----------------
SYNTAX:
------------
<AList> <Type> arraylistobjectname = new <AList><Type>
But type may be Object, int, Double,String,etc.
Why we focus Arraylist ?
Since ArrayList involves Powerful insertion and search mechanism when
compared to array.
So we focus it.
Some built in functions available in ArrayList they are add and remove.
syntax : arraylistobjectname.add(<datatype>);
syntax: arraylistobjectname.remove(<datatype>);
How did you iterate the ArrayList?
<WR> syntax means Iterator; this is the shortest syntax of Iterator.
<WR> iteratorname = <CollectionOBJECT>.record();

LinkedList
----------
<LList> <Type> arraylistobjectname <NEW> <LList><Type>
But type may be Object, int, Double,String,etc.
As according to collection concepts , built in functions are Designed for
LinkedList they are add and remove.
syntax : Linkedlistobjectname.add(<datatype>);
syntax: Linkedlistobjectname.remove(<datatype>);
syntax : Linkedlistobjectname.addFirst(<datatype>);
syntax: Linkedlistobjectname.removeFirst(<datatype>);
syntax : Linkedlistobjectname.addLast(<datatype>);
syntax: Linkedlistobjectname.removeLast(<datatype>);
Actually when you study about Datastructures of LinkedList
and here we Designed the LinkedList using the LinkedList code
as mentioned in above that is LinkedList.c$. And add more functions...
and we use GDollar Generics...
What is the function of LinkedList? Why we use LinkedList?
In ArrayList You can't insert element in to the middle
or first or last so LinkedList is focused....
LinkedList is a Good example of Train....

VECTOR
------------
Vector also has the same Datastructures of ArrayList;
but why we focus? . So vector is simillar to Arraylist.
So we can mention in short notation as VList.
but Vector is synchronized and ArrayList is not Synchronized.
Vector use Enumerator and Iterator but ArrayList use only Iterator.
<VList> <VectorObject> = <NEW> <VList> ();
<VectorObject>.addE(elements);
but vector used add functions
<VectorObject>.first(); => Represent First Element...
<VectorObject>.last(); => Represent Last Element...
<VectorObject>.removeAll(elements); => It is used to remove all elements..
<VectorObject>.removeAt(elements); => remove at Particular position
<VectorObject>.remove(object); => remove the first occurance of the given element
<VectorObject>.remove(index); => Remove by Index or position.

OOPS in GDollar
------------------------------
A) INHERITANCE NOT USING EXTENDS METHOD...

C.GDollar

-------------
<GDollar>
<%
class A
{
public A() { Print.Println("A's called","n"); }
}
class B
{
public B() { Print.Println("B's called","n"); }
}
class C
{
public C() { { Print.Println("C's called","n"); } }
public void GDollar-Main() throws  <EXE>
{
<NEW> A();
<NEW> B();
<NEW> C();
}
}
%>
?>
Output:
------
GDollar: A's called nB's called nC's called n
?>
What is the Output for that?
Tue Aug 18 08:14:53 GMT+00:00 2015*GDollar: A's constructor called nB's constructor called nC's
constructor called n

B) POLYMORPHISM in GDollar
-----------------------------------------------
What is polymorphism?
It is Means action on method to do different things
based on the object that is action upon.
Example:
-------------
Write a Program to compute Rectangle Area and Triangle area
using Polymorphism.
Geometry.GDollar
----------------------------
<GDollar>

<%
class Polygon {
Shared int width, height;
public Shared int set_values (int a, int b)
{ width=a; height=b; return(0); }
}
class Rectangle <--- Polygon {
public int area()
{ return width*height; }
}
class Triangle <--- Polygon {
public int area()
{ return width*height/2; }
}
class Geome<TRY>{
public void GDollar-Main() throws  <EXE>

{
Rectangle rect = <NEW> Rectangle();
Triangle trgl= <NEW> Triangle();
int t= Polygon.set_values (4,5) * Polygon.set_values (4,5);
Print.Println( "Rect area=",rect.area());
Print.Println( "Triange Area=",trgl.area());
}
}
%>
?>
What will be the Output?
Tue Aug 18 07:45:46 GMT+00:00 2015*GDollar: Rect area= 20Triange Area= 10
CAN GDollar Solves diamond Problem in multiple Inheritance?
Yes
C) Write a Progam to List Faculty , students using Diamond method in GDollar
:-
Note: Without Extends methods its calls methods and value when new ()
is intialized.
This is the Major Advantage of GDollar over native programming languages
like JAVA.
Program: TA.GDollar
--------------
<GDollar>

<%
class Person {
// Data members of person
Person(){}
public Person(int x) { Print.Println("Person::Person(int ) called",x); }
}
class Faculty {
public Faculty(int x)
{
<NEW> Person(x);
Print.Println("Faculty::Faculty(int ) called",x);
}
}
class Student {
// data members of Student
public Student(int x) {
<NEW> Person(x);
Print.Println("Student::Student(int ) called", x);
}
}
class TA {
TA(int x) {
<NEW> Faculty(x);
<NEW> Student(x);
Print.Println("TA::TA(int ) called",x);
}
public void GDollar-Main() throws  <EXE>

{
<NEW> TA(30);
}
}
%>
?>
What will be the output ?
Tue Aug 18 07:59:57 GMT+00:00 2015*GDollar: Person::Person(int ) called 30Faculty::Faculty(int ) called
30Person::Person(int ) called 30Student::Student(int ) called 30TA::TA(int ) called 30

How to run this program?
GDOLLARc <Filename.Gdollar>

C) ABSTRACT CLASS
What did you meant by Abstract class?
Abstract class defines an Abstract concept which can't
be instanated using new Operator().
Where compare to multiple Inheritance it has an implementation
where multiple Inheritance cannot have.
<GDollar>
<%
abstract class Abc51
{
abstract void display();
}
public class Abc5 <--- Abc51
{
Shared void display()
{
Print.Println("Wilmix","jemin");
}
public void GDollar-Main() throws  <EXE>
{
display();
}
}
%>
?>
Output:
-------
No output
Note:
------
It will display errors in wl file.
Errors:[Abc5.GDollar:27: display() in Abc5 cannot override display() in Abc51; overriding method is
static]Errors:[ static void display()]Errors:[ ^]Errors:[1 error]
SO when you remove static in display method()
and call display method() in GDollar Main Program
What happens?
Abc5.GDollar: 35: non-static method display() cannot be referenced from a static context
display();
^
1 error
This means it does not allow the Object to be created ......
and it doesnot allow static methods in abstract class.
=========================================================================
More about COLLECTIONS
---------------------------------------------
SET
------
So Set is represented in GDollar as <S>
Syntax:
-----------
<S> Objectname = new <S>();
Difference between Set and List?
List allow duplicates but Set did not allow duplicates...
Set did not allow insertion at middle.
For listing the elements in Ascending or descending order
we had to use TreeSet.
Treeset
------------
Treeset represent a collection that uses Tree datastructure for storage
Items in the collections are stored in Ascending or descending order.
<TS> objectname = new <TS>();
objectname.add(elements);
Write a GDollar Program about Treeset?
remaining things Developer should fill it.
public void GDollar-Main() throws  <EXE>

{
<AList> ar= <NEW> <AList>();
ar.add("1123");
ar.add("211");
ar.add("31");
ar.add("4");
ar.add("100");
<SORTINT>( ar,"ASC");
<SORTINT>( ar,"DESC");
<AList> ar1= <NEW> <AList>();
ar1.add("rahul");
ar1.add("wilmix");
ar1.add("dion");
ar1.add("shiyam");
ar1.add("priya");
ar1.add("abraham");
<SORTSTRING>( ar1,"ASC");
<SORTSTRING>( ar1,"DESC");
}
Output:
------
Order=ASC[4][31][100][211][1123]
*******************************
Order=DESC[1123][211][100][31][4]
*******************************
Order=ASC[abraham][dion][priya][rahul][shiyam][wilmix]
*******************************
Order=DESC[wilmix][shiyam][rahul][priya][dion][abraham]
Operators conditions and loops
--------------------------------------------------
Operators
---------
+ => ADD
++=> Increment
- => Substract
--=> Substract
* => Mulitply
/ = Division
~ => bitwise unary not operator
NOT (!) => flips true values to false and false values to true.
>>, >>>, and << => IT is used to shift all the bits of a number left
or right
a Specified number of places...
Other Operators
----------------
AND => And operator
OR => OR operator
?: => value =condition ? value1 : value2 (similar to if then else)
== => compare two values...
= => Assignment operators
EQ => Compare two objects
Relational Operators
--------------------
> >= => Greater than , Greater than equals.
< <= => Less than , Less than equal
NOTEQ => Equals and not equals
NotEQ simillar to !=
CONDITIONS
----------
IF Syntax:
------------
if <condition> statements;
IF then else Syntax:
----------------------
if <condition> statements else statements1
if <condition> statements1 else if condition1 statement2 .... and soon.
SWITCH Statements:
-------------------
switch (expression)
{
case value1 :
statement1;
[break]
................
case valuen:
statementn;
[break]
-----
default:
default_statement;
}
Explanation:
------------
If the expression is equals value1
statement1 will be executed.
if you use break it comes out of the loop
otherwise it continue to execute next statement.
The default value at the end is optional. It can be included if there are other values that can be held in
your variable but that you haven't checked for elsewhere in the switch statement.
THE WHILE LOOP
-----------------------------
while (<condition> )
{
< Statements block>
}
Note: if the condition is true the block get executed.
otherwise the loop will be continued.
THE DO --- WHILE LOOP
-----------------------------
do
{
< Statements block>
}
while( <conditon> )
Note: if the condition is true the block get executed.
and it is tested at the end of the loop, but not at the
beginning. The loop will be continued until it satisfies the condition.
biggest reason to be use the do - while loop is that
when you need the body of the loop to be run atleast once.
FOR LOOP
--------
for ( identifier=value; cond1; iterator operators)
{
< Block statements >
}
For -EACH Statement
----------------------
for ( variable : collection)
statement;
for eg)
If you add integers (1 to 3) to arraylist
and if you wish to copy and store it in an integer variable
so that you can print the values that is copied from
arraylist.
Then follow this method of for each statements...
for ( int a : ar)
{
GDollar.WriteLine("value="+a);
}
Output:
-----------
value=1
value =2
value =3
CONTINUE and Break
---------------------------------
Break means it break out of loop
and continue means
it will continue to execute the statements;
for eg)
Program :WHILE LOOP with continue and break if statement...
--------------------------------------------------------------------------
<GDollar>
<%
public class WHILE
{
public void GDollar-Main() throws  <EXE>
{
int a=0;
while (a <=10)
{
a++;
GDollar.WriteLine("value="+a);
if ( a==9) continue;
// if you remove this if --else statements it will print all the
values..
else break;
}
}
}
%>
?>
Output:
-------
Wed Aug 19 10:09:23 GMT+00:00 2015*
GDollar: value=1


DATATYPES and OVERLOADING and OVERRIDING CONCEPTS, INNER CLASS
---------------------------------------------------------------------------------------
DATATYPES of GDollar are
-------------------------------
int -> accept only int value
float -> accept float value=>eg) 1.5f
boolean => true or false
character => accept character value
byte -> 1 byte
short -> 2 bytes
long-> 8 bytes
double-> for eg) 1.2121233232E9 => Accept double value
ARRAY => It is used to store values and had fixed size.
ARRAY
-------
SYNTAX:
<Datatype> Arrayname ARRAY [index]
int a ARRAY[1000]; => has 1000 locations to store values...
for two dimension ARRAY
int a[100] ARRAY[100]=> 100 *100 => has 10000 locations to store values
OTHER KEYWORDS IN GDollar
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Frend function
INNER and OUTER CLASS
-----------------------------------------
Inner class are nested inside outer class even if the fields
declared as private members.
<GDollar>
<%
class Outer {
private int privInt = 10;
public void createInnerClass() {
Inner inClass = <NEW> Inner(); //creating innerclass object and calling method
access.
inClass.access();
}
class Inner { // Inner class
public void access() {
GDollar.WriteLine("The outer classs privInt is " + privInt);
}
}
}
%>
OVERLOADING AND OVERRIDING functions
-------------------------------------------
OVERLOADING
------------
A functions with same name but different signature is called
as Overloading concept.
public void display(int i , String j) {}
=> If you pass int and string values from main program it will call
this function.
ABC a = <NEW> ABC(10,"ewew");
public void display(int i, int j) {}
ABC a = <NEW> ABC(10,20);
=> If you pass int and int values it will call this function.
OVERRIDING
-----------
A function with same name and same signature
will cause overriding....
Overriding can be avoided by using super() keyword.
in another class.
<GDollar>
<%
class abc
{
void display(String s)
{
GDollar.WriteLine("We learn C , Dotnet ,and ,GDollar");
}
}
class abcd <--- abc
{
void display(String s)
{
<SUPER>(s); // if super keyword is added we had to pass arguments in
super keyword.
GDollar.WriteLine("We learn C , Dotnet ,and ,JDollar");
}
}
%>
Note: this will cause overriding
and it can be avoided by using super () keyword.

OTHER ATTRACTIVE SYMBOLS in GDollar
-------------------------------------------
--> => implements
<-- => extends
MISC
-----
Program -MISC
-----------------------
<GDollar>
<%
// Advanced concepts : Here Friends is a helper function used in other classes
friends toy
{
public void display();
}
// friends will act like friend function in C++.
class concat1 --> toy
//---> indicates implements toy
{
public void display()
{
GDollar.WriteLine("GDollar is going to be finished");
}
}
public class concat
{
Shared int counter=4;
//Shared means static and which can be accessed over all the objects of
variables.
//<EXE> means throws Exception
// <S> means set
//<WR> indicates iterator
//<SBD> means string builder
//<SB> is String Buffer
// Differences is StringBuffer is Synchronized and
//and String Builder is not Synchronized
//AND means && in JAVA
//NOT means ! in JAVA
//TH means Thread in GDollar
//int <Arrayname> Array [nooflocations] (ARRAY SYNTAX)
//addE means AddElements
public  Shared void  LIB( ) throws <EXE>
{
int i;
String i1="weew";
Print.Println("wilmix",i1);
Print.Println(" \njemin","is going");
<S> <Integer> ar2 = <NEW> <TS> <Integer> ();
ar2.add(100);
<WR> it = ar2.record();
while (it.<HAS>)
{
<OBJECT> el= it.next();
Print.Println("/n",el.StringConvert());
}
<SBD> sb = <NEW> <SBD>("weldone wilmix");
int a;
a=105;
if (( a >100) AND (a<=106))
GDollar.WriteLine("/n"+a);
if (a NOT= 0)
GDollar.WriteLine("/n"+a);
a+=2+counter;
if (a # 107)
GDollar.WriteLine("/n"+a);
TH t = <NEW> TH();
int a11[] <Array> int[100];
a11[0]=1000;
GDollar.WriteLine("/n"+a11[0]);
<VList> v = <NEW> <VList>();
v.addE(100);
GDollar.WriteLine("/n"+v.get(0));
v.removeAt(0);
v.addE(1001);
v.addE(1002);
GDollar.WriteLine("/n"+v.first());
// This is the program for writing program in random access file ;
//it means it can be randomly inserted and retrieved at any location */
//writing word in random accessfile
<RANDOMACCESSFILE> rf = <NEW> <RANDOMACCESSFILE>("concat.c$","rw");
rf.write("Hello World".getBytes());
rf.close();
rf.close();
concat1 obj = <NEW> concat1();
obj.display();
}
}
%>
?>














==================================================================================

UNIT 4
-------
FILE,Other collection concepts,Advanced Concepts of GDollar,MISC-2,Exception and
Error,Garbage collection,Threads,Generics,GDollar Structures.
==================================================================================

Advanced Topics in FILE
-----------------------------
<BUFFINPUTSTREAM> =>you can use <MARK> and <RESET> keyword
to move backward in a buffered input stream.
<DOUTPUTSTREAM> =>
which can be used to write the stream or to do other operations on the stream.
IT USES <WRITEBYTES> TO Write into file.
<DINPUTSTREAM > => USED TO READ STRING FROM
THE FILE. It Uses <READBYTES> TO READ FROM A FILE.
<BREADER> =>Buffered reader uses <READLINE> to read a line from a
file.
<BWRITER> => Buffered writer uses <WRITELINE> to write a line from a
file.
<INPUTREADER> =>
The InputReader is intended to wrap an InputStream, thereby turning the byte based input stream into a
character based Reader.
<FILE> => used fort creating reading ,Appending, and writing string to a file.
Note: Character files are read and written using <FileWriter> and <FileReader>. Writing Streams of
character is best suited using FileWriter.
FileReader
----------
FileReader assumes that default character encoding and default byte-buffer size are appropriate.
FileReader reads character stream.
<FILESREADER>
FileWriter
----------
FileWriter assumes that default character encoding and default byte-buffer size are appropriate.
<FILESWRITER>
OUTPUTWRITER
<OUTPUTWRITER>
The OutputWriter is intended to wrap an OutputStream, thereby turning the byte based output stream
into a character based Writer.
Better than all this random Access file is the best use....
So file concepts are over. SO we ask developers to concenterate on
RandomAccess file....
OTHER COLLECTIONS CONCEPTS
---------------------------------------------------
<M> => map MEANS IT CONTAINS KEYS AND VALUE PAIRS...
HashSet
-------------
SYNTAX:
<HSET> <hashsetname> = <NEW> <HSET>();
HASHMAP
----------------
SYNTAX:
<HMAP> <HASHMAPNAME> = <NEW> <HMAP>();
<HASHMAPNAME>.PUT(key,valuepairs);
<HASHMAPNAME>.GETKEY(index);
<HMAP> mp = <NEW> <HMAP>();
mp .PUT(1, 234);
GDollar.WriteLine(""+mp.GETKEY(1));
HASHTABLE
----------------
SYNTAX:
<HTABLE> <HASHTABLENAME> = <NEW> <HTABLE>();
<HASHTABLENAME>.PUT(key,valuepairs);
<HASHTABLENAME>.GETKEY(index);
<HTABLE> mp = <NEW> <HTABLE>();
mp.PUT(1, 234);
GDollar.WriteLine(""+mp.GETKEY(0));
// This elements can be retrieved by using GETKEY().
note: hash determines a order in which elements are
stored in the hash; SO it will display according
to hash stored order.
ADVANCED CONCEPTS of GDollar
----------------------------------------------------------
GENERIC STACK
-----------------------------
<GS> (we will see later)
ITERATOR
----------------
Iterator iterate about collection
in the forward direction and not in backward direction.
and it will iterate record wise from the List or collection.
<WR> it = collectionobj.record();
where collection obj may be list,arraylsit, and so on.
for EG)
<WR> it = ar.record(); //iterate arraylist.
while(it.<HAS>) // if it has more elements from arraylist
{
<OBJECT> el = it.<NEXT>;
//<OBJECT> is the object..
//<NEXT> is used to list next element from the collection
GDollar.WriteLine(" data= "+el);
//print the elements
}
Listiterator:
-------------
Normally Iterator will not move backward directions
by using iterator. It can be done by using Listiterator.
<LR> <listiterateobject> = Object.<LISTLR>();
eg)
<LR> it1 = ar.<LISTLR>; // iterate the arraylist in backward direction
if you use <PREVIOUS> keyword
while(it1.<HASP>) // if the iterator has more elements
{
<OBJECT> el1 = it1.<PREVIOUS>;
//move to previous record from arraylist
GDollar.WriteLine(" data1= "+el1);
//print the object
}
ARRAYSSORT
---------------------
<A>.<SORT>(arrayname);
SO if you want to sort an array you
must use the keyword <A>.<SORT>(ar);
That means the give array is sorted in ascending order and
store it in array
ARRAYBINARYSEARCH
-----------------
<A>.<BinarySearch>(arrayname,position)
This will search the array in binarysearch wise...
according to the given position.
MISC-EXAMPLE-2
--------------------------
<GDollar>
<%
abstract class misc <--- TH   //implements thread

{
// if variable declared as volatile means Synchronization happens
// at the variable level
// If the variable is declared as Transient
//means transient state is not saved. why we declared a Transient
//variable since it can used in the main program.
// <------- or ------> this means closing or hiding unwanted statements
// <DATE > means DATE
<VOLATILE> int v1;
Shared <TRANS> int v;
~
{
GDollar.WriteLine("object is deleted");
}
public int getnum1()
{
return(v1);
}
Shared int s3;
//simillar to operator overloading in c++.
public Shared void operator *(int s1 ,int s2)
{
s3=s1 * s2;
GDollar.WriteLine(""+s3);
}
public  Shared void  LIB( ) throws <EXE>
{
int a[] <Array> int[1000];
operator *(10,10);
operator *(200,10000);
<AList> ar = <NEW> <AList>();
for(int i=999;i>=0;i--)
{
a[i]=i;
ar.add(i);
}
<A>.<SORT>(a);
for(int i=0;i<=999;i++)
GDollar.WriteLine(" "+i);
GDollar.WriteLine(" "+<A>.<BinarySearch>(a,-5));
<WR> it = ar.record();
while(it.<HAS>)
{
<OBJECT> el = it.<NEXT>;
GDollar.WriteLine(" data= "+el);
}
<LR> it1 = ar.<LISTLR>;
while(it1.<HASP>)
{
<OBJECT> el1 = it1.<PREVIOUS>;
GDollar.WriteLine(" data1= "+el1);
}
<------
while (es.<HASEMORE>)
{
<OBJECT> el11 = es.<NEXTEL>;
GDollar.WriteLine(" data1= "+el1);
}
------>
<DATE> d2 = <NEW> <DATE>();
// print the month of the date
//print the year
//print the hours
//print the seconds
GDollar.WriteLine("month="+<Month>);
GDollar.WriteLine("Year="+<Y>);
GDollar.WriteLine("Hour="+<H>);
GDollar.WriteLine("Sec="+<SEC>);
//<VOLATILE> int v1;
//<TRANS> int v;
// Transient variable is assigned a value 20
v=20;
// Serialization
// Serialization means object stream is
//convert to stream of bytes we can save the object in
//harddisk and sent it across the n/w.
//fileoutputstream
<FOUTPUTSTREAM> os1 = <NEW> <FOUTPUTSTREAM>("out1.txt");
<OOUTPUTSTREAM> d = <NEW> <OOUTPUTSTREAM>(os1);
//object outputstream is used to write an object
///write an object
//write an arraylist object.
//and convert to serializable format.
d.<WRITEOBJ>(v);
d.<WRITEOBJ>(ar);
// read contents form the file
// objectinpustream to read the object...
//Objectread is used to read an object
//used to display the contents from the file in the deserialible format.
// ie, the format the user can read....
<FINPUTSTREAM> osd = <NEW> <FINPUTSTREAM>("out1.txt");
<OINPUTSTREAM> br = <NEW> <OINPUTSTREAM>(osd);
<OBJECT> ar7 = br.<OBJECTREAD>;
GDollar.WriteLine(""+ar7);
<STACK> s= <NEW> <STACK>();
s.<PUSH>(100);
s.<PUSH>(2000);
s.<POP>;
// push 100,2000 and pop last element 2000 and print it
GDollar.WriteLine(""+s);
<PRIORITYQUEUE> q = <NEW> <PRIORITYQUEUE>();
q.add(1000);
q.add(544);
q.add(66);
q.add(667888);
//add some elements to priority queue and print it
GDollar.WriteLine(""+q);
}
}

%>
?>
Exception and ERROR
-----------------------------------
Exception is a abnormal condition that arise during
the code sequence at run time.
What are the two Types of Exception?
Checked and Unchecked Exception.
Exception that arise during the run time are called as
Unchecked exception.
Thrown exception are refer to the checked exception.
Unchecked Exception
--------------------
<Arithmetic> -> Arithmetic exception
<ArrayIndex> -> ArrayIndex outof bound exception
<ArrayStore> -> Assignment to an array of an incompactible type.
<IndexOut> -> Index out of boud exception
<NegativeArraySize> -> Array Created with a negative array size.
<NullPointer> -> Null pointer exception
<NumberFormat> -> invalid conversion of string to numeric format.
typing or giving data string as input in integer datatype.
<SecurityException> -> Attempt to violate security
<StringIndex> ->Attempt to acess index ouside the bounds of a string.
Checked Exception
-----------------
<ClassNotFound> -.> class not found
<CloneNotFound>-> Clone keyword is absent
<IllegalAcess> -> Access to a class is denied.
<Instanation>-> Attempt to create an object of abstract class or friendly functions
<Interrupted>=> One thread has interrupted by another thread.
<NoSuchField> => A request field doesnot exist
<NoSuchMethod>=> Request emthod doesnot exist.
<TRY> -> try in C/JAVA
<CATCH> -> catch in c/java
<Finally> -> final in c/java
SYNTAX:
-------------
<TRY>
{
< Executable good statements>
}
<CATCH> (<EXE> e)
{
GDollar.WriteLine(""+e);
}
<Finally>
{
<Final block statements>
}
Explanation:
-------------------
When ever the Exception is true statements inside a try
block is executed; otherwise
statements inside a catch block is executed.
Exception occurs or not
final block get executed..
FINAL in GDollar
--------------------------
UnShared keyword means final in GDollar
eg)
UnShared int i=9;
// if a variable is declared as final
that value can't be changed.
eg)
UnShared class abc
{
.......
}
if the class is declared as UnShared it can't
be overridden.
so if the method is declared as UnShared
such method can't be overriden by another class method.
GARBAGE COLLECTION
-------------------
<RECYCLE> => Garbage colection
eg) if you allocate elements a=9;
but doesnot use in the program so such object
are garbage collected by using <RECYCLE> keyword.

THREADS
--------------
A thread is a path of execution that run on CPU
and process is a collection of thread that share a same virtual
memory.

SIMPLE THREAD
----------------------------
<GDollar>
<%
public class threads1 <--- TH
{
public <Str> str;
public void <RUN>
{
for (int i=0;i<=10;i++)
GDollar.WriteLine(""+str);
}
public  Shared void  LIB( ) throws <EXE>
{
threads1 t = <NEW> threads1();
t.str = "thread1";
t.<START>; //start first thread
threads1 t1 = <NEW> threads1();
t1.str = "thread2";
t1.<START>; // start second thread.
//here after the thread1 get executed thread 2 is executed....
}
}
%>
?>

SYNCHRONIZED:
------------
If multiple clients want to access the shared resource
synchronization provide the way for the multiple clients
not for the specific one.
BIG Program for Synchronization
----------------------------------
<GDollar>
<%
class threads
{
public  Shared void  LIB( )
{
My thread1 = <NEW> My("thread1: ");
My thread2 = <NEW> My("thread2: ");
thread1.<START>;
thread2.<START>;
boolean thread1IsAlive = true;
boolean thread2IsAlive = true;
do {
if (thread1IsAlive AND NOTthread1.isAlive()) {
thread1IsAlive = false;
GDollar.WriteLine("MY DOG 1 is dead.");
}
if (thread2IsAlive AND NOTthread2.isAlive()) {
thread2IsAlive = false;
GDollar.WriteLine("MY DOG 2 is dead.");
}
} while(thread1IsAlive || thread2IsAlive);
}
}
class My <--- TH
{
Shared <Str> message[] ={ "GDollar", "is", "combination", "of", "JAVA", "and c"};
public My(<Str> id)
{
<SUPER>(id);
}
public void <RUN>
{
SyncOut.displayList("welcome",message);
}
void randomWait()
{
<TRY> {
<SLEEP>((long)((300)));
} <CATCH> (<Interrupted><EXE> x) {
GDollar.WriteLine("Interrupted!");
}
}
}
class SyncOut
{
public Shared <Synchronized> void displayList(<Str> name,<Str> list[])
{
for(int i=0;i<list.length;++i) {
// TH means Thread
My t = (My) TH.currentTH();
t.randomWait();
GDollar.WriteLine(name+list[i]);
}
}
}
%>
?>
 GDOLLARc threads.GDollar
WAIT
--------
It WAITS indefinitely for another thread of execution until it receives notify
or notify all message.
<WAIT>
NOTIFY AND NOTIFYALL
----------------------------------------
<NOTIFY> ->
The keyword process waits for a single thread waiting on a
object monitor.
ALL ->
The keyword process waits for a multiple thread waiting on a
object monitor.
JOIN
--------
join() method
This Process join with another thread after another thread finishes the
execution.
eg) Thread t1 => Wait for 100 seconds
and Thread t2 => will execute after Thread t1 complets the execution.
This is the meaning of join process in Thread.

GDollar ADVANCED CONCEPTS
--------------------------------
STACK
---------
Stack means lastin first out.
A stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO)
principle.
In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item
out of the stack.
<STACK> s= <NEW> <STACK>();
s.<PUSH>(100); // PUSH operator to push the elements into stack
s.<PUSH>(2000);
s.<POP>;
GDollar.WriteLine(""+s);
Output:
[100]
Priority Queue:
---------------------
Many applications require that we process items having keys in order, but not necessarily in full sorted
order and not necessarily all at once.
Often, we collect a set of items, then process the one with the largest key, then perhaps collect more
items, then process the one with the current largest key,
and so forth. An appropriate data type in such an environment supports two operations:
remove the maximum and insert. Such a data type is called a priority queue.
<PRIORITYQUEUE> q = <NEW> <PRIORITYQUEUE>();
q.add(1000);
q.add(544);
q.add(66);
q.add(667888);
GDollar.WriteLine(""+q);
Output:
-------
[66, 1000, 544, 667888]
Destructor:
----------
Destructor means object is going to be destroyed.
~
{
GDollar.WriteLine("object is deleted");
// this means object is going to be destroyed.
}
where ~ is the Destructor

Operator Overloading in GDollar
------------------------------------------------
This means we can overload the operators
like + - = / > < >= <=
Compare CompareTo
public Shared void operator *(int s1 ,int s2)
{
s3=s1 * s2;
GDollar.WriteLine(""+s3);
}
public  Shared void  LIB( )
{
operator *(10,10);
// You are passing * Multiply Operator in the main Program
operator *(200,10000);
}
GENERICS
---------------
GENERICS means which is used to Pass Type as argument as class
for example if you want to pass String , int, float datatypes at the
same time and if you use display method to display the value of any
datatype
so Generic is most useful in that case.
<GDollar>

<%
public class GEN<T>
{
T t;
T display(T t1)
{
t=t1;
return(t);
}
public  Shared void  LIB( )
{
GEN <Integer> i = <NEW> GEN<Integer> ();
GDollar.WriteLine(""+ i.display(10));
}
}
%>
?>



=================================================================
GDollar STRUCTURES
-----------------------------------
GDollar structure is another user defined data type available in GDollar programming, which allows
you to combine data items of different kinds.
using the same memmory location. It also provide an efficient way of using the same
memory location for multi-purpose.
Thus GDollar Structures is Equivalent = C progamming Structures and union.
and it uses less memmory capacity than any Programming languages. IT is also
used to store collections, objecte ,etc.
IT is the most important datastructure implemented by wilmix jemin j.
He reduces the demerits of C Programming and
C child is GDollar. So GDollar has very beautiful and Advanced Concepts
than
any Programming Languages. And the Native Technology like JAVA
fails to do.
Program-1:
---------
class structeg // define a class
{
Shared int sno; Shared int m1,m2,m3;
Shared double avg=0.0;
structeg(int sno,int m1,int m2,int m3,double avg)
{
<IS>.sno=sno;
<IS>.m1=m1;
<IS>.m2=m2;
<IS>.m3=m3;
<IS>.avg=avg;
}
public  Shared void  LIB( )
{
sno=1;
m1=234;
m2=456;
m3=656;
avg=((m1+m2+m3)/3);
structeg s = <NEW> structeg(sno,m1,m2,m3,avg); // create an object of a classs
structeg s2 = <NEW> structeg(sno,m1,m2,m3,avg); // create an object of a classs
<STRUCTURE> <<OBJECT>> list = <NEW> <STRUCTURE> <<OBJECT>>(s);
list.add(s2);
//add the Objects to structures....
for (int i = 0; i NOT= list.size(); i = i + 1) //compute the size of structures
{
<OBJECT> el=list.ret(i);
structeg s1= (structeg)el;
//made class objects equals structure objects and cast using structure ....
GDollar.WriteLine("SNO= "+s1.sno);
GDollar.WriteLine(" m1="+s1.m1);
GDollar.WriteLine(" m2="+s1.m2);
GDollar.WriteLine(" m3="+s1.m3);
GDollar.WriteLine(" AVG="+s1.avg);
GDollar.WriteLine(" size="+list.size());
}
}
}
%>
?>
What will be the Output?
OUTPUT:
------------
Fri Aug 21 13:29:21 GMT+00:00 2015*GDollar:
SNO= 1 m1=234 m2=456 m3=656 AVG=448.0 size=2 SNO= 1 m1=234 m2=456 m3=656 AVG=448.0 size=2
ADVANTAGES:
--------------------
Billing programs, GUI, Record wise Search and Printing ,etc...













==================================================================================

UNIT-5 :GDollar  NETWORKING
==================================================================================

GDollar Networking
-------------------------------------
N/w are essential to our life. Intenet is born due to networking and
A method of Client -server communications
gives like a house - to house interaction.

CLIENT SERVER PROGRAM
--------------------------------

<GDollar>
<%
class CLIENTSERVER
{
public  Shared void  LIB( )
{
<CLIENT>("WILMIX","1099"); // Declare client and call client and pass hostname and port
<SERVER>("1099");//Declare server and server and pass portno
}
}
%>
?>
OUTPUT:
-------
Sat Aug 22 08:52:19 GMT+00:00 2015*GDollar: Connecting to WILMIX on port 1099Waiting for client on
port 1099...Socket timed out!

==================================================================================
UNIT -6: MISC ,Advanced Concepts
==================================================================================
Let us consider a Program to print using WHILE LOOP
Program -1
----------
<GDollar>

<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
GDollar.WriteLine("value="+a);
}
}
}
%>
?>
Compilation:
GDOLLARc WHILE.Gdollar
Output:
(note: at One time compilation you will get this output in windows platform)
********************************************************************
Tue Mar 01 1
3:30:08 IST 2016*JAS: Error:
***************************************************
******************************************
WHILE Tue Mar 01 13:30:09 IST 2016 GDollar:
Output: value=1value=2value=3value=4value=5value=6value=7value=8value=9value=10va
lue=11Error: value=1value=2value=3value=4value=5value=6value=7value=8value=9valu
e=10value=11
========================================
What is Pointers?

Variables that hold memory address are called pointers.
Why we mainly use Pointers?
Pointers reduces the length and complexity of the program,
They increase the execution speed.
It holds the memmory addres..
SYNTAX of GDollar Pointers:
---------------------------------
{*}<<DATATYPE>> <pointer-name> Pointer<<DATATYPE>>(intialvalue);
for eg)
<Str> s ="Life is beautiful";
{*}<<Str>> l Pointer<<Str>>(s);
The given above statement will store the string "Life is beautiful"
in Pointer name l;
Write a program to store the value in pointers
--------------------------------------------------------------
<GDollar>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
{*} l Pointer(0); //store value 0 in pointer name l
while (a <=10)
{
a++;
l.add(a); // add all the values in pointer
}
for (int i = 0; i NOT= l.size(); i = i + 1) // compute the size and perform for loop
{
<OBJECT> obj=l.get(i); // ge the value by index i
GDollar.WriteLine(" value="+obj+ " "); // print the value
GDollar.WriteLine(" ");
GDollar.WriteLine(" Address= "+l); // print the memory address..
}
}
}
%>
?>
Compile using this command: GDOLLARc WHILE.Gdollar
OUTPUT:
------------
Array=1Compiling ....
*************************************************************************************
********
Tue Feb 09 19:37:22 GMT+00:00 2016*GDollar: value=0 Address= ptr@187aeca value=1
Address= ptr@187aeca value=2 Address= ptr@187aeca value=3 Address= ptr@187aeca
value=4 Address= ptr@187aeca value=5 Address= ptr@187aeca value=6
Address= ptr@187aeca value=7 Address= ptr@187aeca value=8 Address= ptr@187aeca
value=9 Address= ptr@187aeca value=10 Address= ptr@187aeca value=11
Address= ptr@187aeca
Note: We notice GDollar pointers stores the values at same memory location
is the greatest Advantage in GDollar Programming...

What will happen when you use GDollar pointer with ArrayofArray to the
WHILE.GDollar ->
GDollar-Main( ) ....?
GDOLLARArrays list1 = <NEW> GDOLLARArray("THINGS ");
list1.add("1 mat");
list1.add("2 mouse");
list1.add("3 pen");
list1.add("4 coat");
list1.add("5 printer");
list1.add("6 laptop");
list1.Display();
for (int i1 = 0; i1 NOT= l.size()-1; i1 = i1 + 1)
{
<OBJECT> obj1=list1.get(i1);
GDollar.WriteLine(" value="+obj1.StringConvert()+ " ");
GDollar.WriteLine(" ");
}
OUTPUT:
Compiling ....
*************************************************************************************
********
Tue Feb 09 19:56:37 GMT+00:00 2016*GDollar: value=0 Address= ptr@187aeca value=1
Address= ptr@187aeca value=2 Address= ptr@187aeca value=3 Address= ptr@187aeca
value=4 Address= ptr@187aeca value=5 Address= ptr@187aeca value=6
Address= ptr@187aeca value=7 Address= ptr@187aeca value=8 Address= ptr@187aeca
value=9 Address= ptr@187aeca value=10 Address= ptr@187aeca value=11
Address= ptr@187aeca, , , , , , , [{ 1 mat }{ 2 mouse }{ 3 pen }{ 4 coat }{ 5 printer }{ 6 laptop } ]
value=ThreadINGS value=1 mat value=2 mouse value=3 pen value=4
coat value=5 printer value=6 laptop
Note: Again GDollar pointers stores the values at same memory location
is the greatest Advantage in GDollar Programming...

Write an example to exchange the Pointer values using functions?
-------------------------------------------------------------------------------
<GDollar>
<%
public class func
{
Shared int a=100; // make the variable as static
Shared {*} l1 Pointer(a); // declare l1 pointer and assign a value
Shared int b=10000;
Shared {*} l2 Pointer(b); // declare l2 pointer and assign a value
Shared {*} l3 Pointer(0); // declare l1 pointer and assign a initial value
public  Shared void  LIB( ) throws <EXE>
{
int a=0;
func.exchange(l1,l2); // pass the pointer object to exchange functions...
GDollar.WriteLine(""+ l1.get(0)+""+l2.get(0));
}
public Shared void exchange(<OBJECT> a,<OBJECT> b) // declare the parameters as
object
{
l3=l1; // assign l3 pointer = l1
// l3 pointer will point to l1 address
l1=l2; // assign l1 pointer = l2
l2=l3; /assign l2 pointer = l3
}
}
%>
?>
Output  if  you  use  GDollar main:
Tue Feb 09 20:20:40 GMT+00:00 2016*GDollar: 10000 100
Now let us see an example using GDollar Pointers with structures...?
-----------------------------------------------------------------------------------
<GDollar>
<%
// define a class
class p<STRUCTURE>eg
{
Shared int sno; Shared int m1,m2,m3;
Shared double avg=0.0;
p<STRUCTURE>eg(int sno,int m1,int m2,int m3,double avg)
{
<IS>.sno=sno;
<IS>.m1=m1;
<IS>.m2=m2;
<IS>.m3=m3;
<IS>.avg=avg;
}
public  Shared void  LIB( )
{
sno=11;
m1=234;
m2=456;
m3=656;
avg=((m1+m2+m3)/3);
//create a structure and pass the values as arguments
// to structures..
p<STRUCTURE>eg s = <NEW> p<STRUCTURE>eg(sno,m1,m2,m3,avg);
// create an object of a classs
<STRUCTURE> <<OBJECT>> list = <NEW> <STRUCTURE> <<OBJECT>>(s);
list.add(s);
//add the Objects to structures....
{*} l Pointer(0);
//compute the size of structures
for (int i = 0; i NOT= list.size()-1; i = i + 1)
{
<OBJECT> el=list.ret(i);
p<STRUCTURE>eg s1= (p<STRUCTURE>eg)el;
// add structure values to pointer
l.add(s1.sno);
l.add(s1.m1);
l.add(s1.m2);
l.add(s1.m3);
l.add(s1.avg);
}
for (int i = 0; i NOT= l.size()-1; i = i + 1)
{
GDollar.WriteLine("LIST= "+l.get(i)+" "); // print the values from pointer
}
}
}
%>
?>
OUTPUT:
Tue Feb 09 21:01:23 GMT+00:00 2016*GDollar: LIST= 0 LIST= 11 LIST= 234 LIST= 456 LIST= 656

GDollar File Manipulation:
-----------------------------
G$ file Manipulation contains
Insert , Insertrows, retrieve functions ....
This shortcut functions are mostly used for filemanipulation....
Now let us see GDollar Program with Security and Filemanipulation?
<GDollar>
<USE>  Securitydb.*; => importing GDollar security package.....
<%
public class WHILE
{
public  Shared void  LIB( ) throws <EXE>
{
int a=0;
{*} l Pointer(0); => Intialize the pointer to 0.
while (a <=10)
{
a++; //increment a value
l.add(a); //store the values in pointer
}
for (int i = 0; i NOT= l.size(); i = i + 1) // use l.size() to compute pointer size.
{
<OBJECT> obj=l.get(i); // get the value of pointer
GDollar.WriteLine(" value="+obj+ " "); // print the value
GDollar.WriteLine(" ");
GDollar.WriteLine(" Address= "+l); // print the address
GDollar.WDBA.Manipulation.InsertRows(obj.StringConvert(),"wil.txt"); //store the values in
// wil.txt
}
Array list1 = <NEW> Array("THINGS "); // use array of array
list1.add("1 mat");
list1.add("2 mouse");
list1.add("3 pen");
list1.add("4 coat");
list1.add("5 printer");
list1.add("6 laptop");
list1.Display();
GDollar.WDBA.Manipulation.insert(list1.get(1),"wil1.txt"); // store array of array objects in
//wil.txt , this will insert a file new if text is present in wil1.txt
//it will truncate he text and insert newly...
// insert function performs replace the text again
<AList> ar5 = <NEW> <AList>();
for (int i1 = 1; i1 NOT= list1.size()-1; i1 = i1 + 1)
{
<OBJECT> obj1=list1.get(i1);
GDollar.WriteLine(" value="+obj1.StringConvert()+ " ");
GDollar.WriteLine(" ");
GDollar.WDBA.Manipulation.InsertRows(obj1.StringConvert(),"wil.txt");
// Insertrows perform update and insert the text again
// for eg) if you insert using insertrows 'house is' in wil.txt and if you
insert using insertrows 'located at caifornia" in wil.txt
// so the text file contains only "house is located at california" string.
}
GDollar.WriteLine(" OUTPUT from file= "+GDollar.WDBA.Manipulation.retrieve("wil.txt"));
// retrieve from file wil.txt
GDollar.WriteLine(""+GDollar.WDBA.Manipulation.retrieve("wil1.txt"));
// retrieve from file wil1.txt
Secure.InsertSecure("wil.sdb", 0,"while","while",GDollar.WDBA.Manipulation.retrieve("wil1.txt"));
//store the text in wil.sb security file using security.InsertSecure
so the hackers or any users can't access it.
GDollar.WriteLine("Security file contents wil.sdb......");
Secure.SretreiveSecure("wil.sdb" ,0); //retrieve the contents from security file and print
it to the //console
}
}
%>
?>
OUTPUT  when  you use  GDollar  main:
----------------------------------------------
Mon Feb 15 10:51:27 GMT+00:00 2016*GDollar: value=0 Address= ptr@e48e1b value=1
Address= ptr@e48e1b value=2 Address= ptr@e48e1b value=3 Address= ptr@e48e1b
value=4 Address= ptr@e48e1b value=5 Address= ptr@e48e1b value=6
Address= ptr@e48e1b value=7 Address= ptr@e48e1b value=8 Address= ptr@e48e1b
value=9 Address= ptr@e48e1b value=10 Address= ptr@e48e1b value=11
Address= ptr@e48e1b, , , , , , , [{ 1 mat }{ 2 mouse }{ 3 pen }{ 4 coat }{ 5 printer }{ 6 laptop } ] value=1
mat value=2 mouse value=3 pen value=4 coat value=5 printer
OUTput from file= 012345678910111 mat2 mouse3 pen4 coat5 printer012345678910111 mat2
mouse3 pen4 coat5 printer012345678910111 mat2 mouse3 pen4 coat5 printer012345678910111 mat2
mouse3 pen4 coat5 printer012345678910111 mat2 mouse3 pen4 coat5 printer1 mat
Security file contents wil.sdb......
<tr><td>1 mat</td>
==============
BUCKET
-------
Bucket are used to store key,value data, and Generated Random number
where datatype may be string ,object ,etc.
SYNTAX:
----------
Bucket<DATATYPE> list = <NEW> Bucket<DATATYPE>(<DATATYPEVALUE>);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages
----------
Using Bucket you can also Retrieve the values stored n position.
Searching and Insertion is fast than other DTS.
Random Indexing is possible.
eg) If you store a duplicate value such Random key will be different.
It also used to add many values.
EXTEND
------
Extend class is used in GDollar since to provide multiple inheritence
about 100000000 classes . Extends class also list values in methods and
constructor values.
Extend means a Bucket contains List of class and it is also
Behave like Bucket. So it is also one of the Advanced concepts in GDollar.
SYNTAX:
--------
EXTEND <<DATATYPE>> list11 = <NEW> EXTEND <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages:
It is also used to add many values
Indexing is possible
Value can also be list by index and behave like bucket.
It list only the class value and object value.
It is stateless.
PIPE:
-----
PIPE is used to maintain stateful state.
It is used for DataFlow in a Program. We can also add the values,
Constructor values of one class and other class and display it.
It also list the values from the Bucket.

SYNTAX:
-------
Pipe <<DATATYPE>> list11 = <NEW> Pipe <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Why we Prefer GDollar for software Field?
Used in BILLS, Forms ,Reports,Charts, any software project , GRAPHICS to web etc.














==================================================================================

UNIT -7 :GDollar CODING STANDARDS AND ADVANTAGES OVER OTHER
PROGRAMMING LANGUAGES
==================================================================================


Coding Standards of GDollar
------------------------------
<GDollar>
<Serialize>
<Statements>
</Statements>
?>
Note : <Statements> and </Statements> is used to write class and it's logic.
ALL Program should Start with <GDollar> means starting of a Program and
scucceded by <Serialize>
to load GDollar packages and ?> Means End of the Program.
HIDE Unwanted code
--------------------
<------ program code ------>
MAIN Program:
-------------
public  Shared void  LIB( ) indicates MAIN Program
otherwise it will not run the Program
STATIC BLOCK
-------------
Shared means Static keyword.
Shared will be executed first after that Main program will
be executed.
Shared
{
}
{} => This curly braces are mostly used.
SOME OPERATOR KEYWORDS
-------------------------
AND => && in java
NOT => !
# => !=
NEW Keyword
---------------
NEW is used to create an instance in memmory.
Always concenterate on important keyword not need to
memmorize at all.
DATATYPES:
-----------
int , char, double , float are ordinary keywords of oops
Programming language like C/JAVA/C#/GDollar.
STRUCTURES:
-----------
Always use Structure DATATYPE to store your data in objects form
so that it will reduce the storage allocation in memmory.
for one object it takes only 1 byte of memmory for structures.
RECYCLE:
-------
Always use RECYCLE to make the unwanted object to be garbage collected.
//
----
If you want to describe something about your functions
use // . Don't use it unnessary at any way.
Special Characters
--------------------
@,$%,^,[] are not allowed in the CDOLLLAR program
~
---
Use Destructor keyword to specify non GDollar resource deletion code to
be goes when you it..
Other Things
-------------
for loop , if statements, while loop, do while ,
for each, Switch statements, AutoBoxing , Generics , etc
are same.
Did GDollar support pointer?
-----------------------------------
YES.
private LinkedList nextNode =null;
consider this line ; This line creates a pointer to a class
LinkedList .
nextNode=new LinkedList(datum);
This statements are use to insert first data to Linkedlist
nextNode.add(datum) is used to insert many data....
Class Inheritance
-------------------
If the Class is using another class variable in that case
you had to use <--- "extends" backward arrows
and front arrows --> for implements..
Implements is used when you use friend function.

GDollar ADvantages over JAVA and other Programming Languages
----------------------------------------------------------------------------------
A) GDollar is the combination of JAVA , C/C++, and Advanced OOPS.
b) GDollar will only accept the shortest attractive syntax.
c) GDollar also used for construction of any datastructures.
d) GDollar helps the developers to provide inheritance by not using extends
keyword
and call the class in main program when use in linux.
e) GDollar Solves diamond Problem with multiple Inheritance when used in linux.
f) It also supports friendly function, pointers , and structures.
g) GDollar support Virtual memmory and garbage collection.
h) It is efficient, fast and easy to understand, and it is a OOPS Technology.
i) GDollar is a High level language.
j) GDollar is highly portable language
k) Using GDollar you can create any datastructures as libraries and
use it in your Application program.
l) GDollar language is a structured and object programming language.
m) GDollar has OOPS concepts like JAVA.
n) GDollar have the concept of Packages,etc.
o) GDollar have the concept of constructor or destructor and had magic oops concepts.
p) It Support functions with Default Arguments
q) It Supports Exception handling
r) It Support Generic Programming
s) It have pointer and Nodes..
t) GDollar is much simpler oops concepts, which leads to faster development and less mental
overhead.
u) GDollar is almost always explicitly compiled
w) GDollar is easy to learn. GDollar was designed to be easy to use and is therefore easy to write,
compile, debug, and learn than other programming languages.
GDollar is object-oriented. This allows you to create modular programs and reusable code.
GDollar is platform-independent.
x) GDollar creates   .exe  or  .dll   files   and  it  can be  used  with   GDollar  main  program   (CWE  EDitor  )   to  create  a  complete  software.
y) GDollar will compile and run at same time where other technology can't
do
z) GDollar is mainly used in complex programming , Billing the
goods,Graphics,etc
AA) GDollar is platform independant language
BB) GDollar is an interactive Technology.
CC) GDollar  is   used  only  in  companies  and  industries.
DD)  GDollar  is used   in  compiler design  and  datastructures construction.




==============================================================================

UNIT -8 :GDollar MAIN  Program Syntax  AND ADVANCED   CONCEPTS  PROGRAM.


==============================================================================

Syntax:


<GDollar>
<INVOKE>
<PACK> <NAMESPACE>

    <CLASS> <CLASSNAME>
    {
        public FLOAT GDollar-MAIN()
        {
            
<!  GDollar  Logic  !>              
               
     



?>



BAG
=====
Bag is the extension of LinkedHashmap and it is the fastest
datastructures than
Dictionary.

SYNTAX:
=======
<GDollar>
<INVOKE>
<PACK>  bags

    <CLASS> bags
    {
        public FLOAT GDollar-MAIN()
        {
            
        Bag  b <NEW> Bag();

b.PUT(1,34); //  KEY  AS  1  AND  VALUE  AS  34
b.PUT(2,444);

<PRINTLN>(""+b);
              
               
     



?>



Bag object = new Bag();
object .put(key,value);
Functions
getValues(key) => it is used to get the values for a particular key
get(key,loc) => it is used to get the value stored at a loc (indexing
purpose)
boolean containsValue(object Value) => To check the value present in bag or
not.
put(key,value) => it is used to add key and value in Bag
remove(key ,value) => It is used to remove key and value.



TreeList
========

TreeList simillar to Bucket but store items in tree format.

TreeList list = new TreeList ("BUCKETS");
list.KeyAdd(KEY);
list.add(VALUE1);
list.RandomAdd(RANDOMNO);
list.DisplayO(list,0);


MASK
====
It is the extension of Tree Structure and it can store many values
using mask object and we can also retrieve the values stored in mask.
Mask m = new Mask(<DATATYPE>);
m.add(multiple values);
m.getR(Loc); => Get the values stored in right position
m.getL(LOC) => Get the values stored in left position


HEAP:
====


Creates a tree , puts the data into tree in a fairly balanced way and displays
the tree's size and data in a tree by performing an inorder traversal.
Heap hob = new Heap(<datatype>);
hob.add(datum);
hob = new Heap(key,value1,value2);



Bucktist
==========



Bucktist is simillar to Bucket but it is used to addd two values with one
key.
Bucktist l = null;
l= new Bucktist(key,value1,value2);


WICKET
=======
Wicket is used to store multiple values using same object with
4 values per key.

Syntax:

Wicket list12;
list12=new Wicket(key,v1,v2,v3,v4);
list12.Display();
list12.Display(list12,location);




EXAMPLE -1: BAG

<GDollar>
<INVOKE>
<PACK> MyP

    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
            
        Bag  b <NEW> Bag();

b.PUT(1,34);
b.PUT(2,444);

<PRINTLN>(""+b);
              
               
     



?>


EXAMPLE:2  : GDOLLARARRAYS
==========

<GDollar>



<PACK> MyP
{
    <CLASS> Programs
    {
         
        public FLOAT GDollar-MAIN()
        {
            


 
 
 
 <CDOLLARARRAYS> list1 <NEW>  <CDOLLARARRAYS>("ANIMALS ");
        list1.add("1 horse");
 list1.add("2 pig");
 list1.add("3 cow");
 list1.add("4 goat");
 list1.add("5 chicken");
 
 list1.add("6 ostrich");

 list1.Display();

 
              


?>


EXAMPLE-3: CREATE  AN  BOOTLOADER   Using  GDollar

 <GDollar>

<PACK>  MYOS
{
    <CLASS> MYOs
    {
public FLOAT GDollar-MAIN(){


<PRINTLN>("HelloWorld  for  booting  MYOS");

          
               
     </Statements>

?>




EXAMPE-4: POINTERS


<GDollar>
<PACK> MyP
{
    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers (s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
              
                


?>


EXAMPLE-5: DICTIONARY


<GDollar>
<USE> System.Collections.Generic;

<PACK> MyP
{
    <CLASS> Programs
    {
         
        public FLOAT GDollar-MAIN()
        {
            

 Dictionary<string, string> openWith  <NEW>  Dictionary<string, string>();
openWith.Add("txt", "notepad.exe");
openWith.Add("bmp", "paint.exe");
openWith.Add("dib", "paint.exe");
openWith.Add("rtf", "wordpad.exe"); 
              
             


?>



Example-6: EXTEND



<GDollar>

<INVOKE>



<PACK> MyP


    <CLASS> Programs

        public FLOAT GDollar-MAIN()

        {
 
 
 EXTEND list <NEW> EXTEND("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);
                    
<PRINTLN>(""+list.DisplayO(list,1));

 



?>


EXAMPLE-7: HEAP


<GDollar>


<PACK> MyP
{
      <CLASS> Programs
    {
         public FLOAT GDollar-MAIN()
        {
 

 Heap root <NEW> Heap("wilmix");
 
 for (int i = 0; i <= 10; i = i + 1)
 {
 root.add("item " + i);
 }
                 
 <PRINTLN>(root.size() );
 root.printTree();

          


?>



Example-8: LArray


<GDollar>

<USE> CUTIL;

<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()
        {
 
 LArray root <NEW> LArray("root");
 
	
<ArrayList> ar <NEW> <ArrayList>();
 
 
 for  (int  i=0;i<=1000;i++)
 
 ar.add(i,i);
 
 root.add("wilmix");
 root.add("jemin");
 root.add("shalom");
 root.add("1010");
 root.add("101");
 root.add("201");
 root.add(ar.StringConvert());
 root.add("100000000");
 //print the tree's size and contents
 
 root.printTree();



          
               


?>


Example-9 : PIPE



<GDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
public FLOAT GDollar-MAIN()
        {
 

Pipe list  <NEW> Pipe("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);

<PRINTLN>(""+list.DisplayO(list,1));

 
          
               


?>




EXAMPLE-10: TREELIST



<GDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
        public FLOAT GDollar-MAIN()
        {
 


TreeList list  <NEW> TreeList ("BUCKETS");
 
 
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                    
                     
                     list.RandomAdd("1111");   

TreeList list2 <NEW> TreeList("BUCKETS");
 list2.KeyAdd("1102");  
                    
                     list2.add("rahul");
                    
                     
                     list2.RandomAdd("1112");
                     
                 


<PRINTLN>("DATA="+list.DisplayO(list,0));


<PRINTLN>("DATA="+list2.DisplayO(list2,0));

          
               


?>


Example-11 : MASK



<GDollar>



<PACK> My
{
    <CLASS> Programs
    {
           public FLOAT GDollar-MAIN()
        {
 

 MASK root <NEW> MASK("wilmix");
 
 for (int i = 0; i NOT= 10; i = i + 1)
 {
 root.add("item " + i);
 }
             
 
 
 
 
 root <NEW> MASK("root1",1211211,54441);
 
 root  <NEW> MASK("root2",121121,5444);
 root  <NEW> MASK("root5",99121888,"5");
 
 root  <NEW> MASK("root3",12112,544);
 
 root  <NEW> MASK("root4",1211,54);
 
 root  <NEW> MASK("root51",121,5);
 
 
 root.printTree();
 


          
               


?>





Example-12 : WICKET


<GDollar>


<PACK> MyPo
{
    <CLASS> Programs
    {
           public FLOAT GDollar-MAIN()
        {
 Wicket  list12;
 list12 <NEW> Wicket(1000,10002,43433,4343,5555451);
 list12 <NEW> Wicket(10001,100021,434331,4343,5555452);
 list12 <NEW> Wicket(10002,100022,434332,4343,5555453);
 list12 <NEW> Wicket(10003,100023,434333,4343,5555454);
 list12 <NEW> Wicket(10004,100024,434334,4343,5555455);
 list12 <NEW> Wicket(10005,100025,434335,4343,5555456);
 
 
 list12.Display(list12);
 
 <PRINTLN>("DATA="+list12.DisplayO(list12,0));
                 
          
               

?>


Example-13 : STRUCTURE


<GDollar>
<PACK> MyPoi
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()

        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers(s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
 
 
 <STRUCTURE>  list <NEW> <STRUCTURE> (l.GETKEY(0));
 
 for (int i11 = 0; i11 NOT= list.size(); i11 = i11 + 1)
 {
 
 
 
 <OBJECT>  el=list.ret(i11);
 

 
 <PRINTLN>("SNO= "+el);

                }
              
            
               


?>




Example-14 : BUCKETIST


<GDollar>
<INVOKE>


<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT GDollar-MAIN()
        {
 




Bucketist  bp    <NEW>  Bucketist("wilmix");

bp    <NEW>  Bucketist(1,222,434);
bp   <NEW>  Bucketist(1,222,434);


bp.Display(bp);


<PRINTLN>("DATA="+bp.DisplayO(bp,1));
          


?>


==============================================================================

UNIT-9:   G  D  O  L  L  A  R   Technology focused for  Compiler Design  and  datastructures  design,Regular  Expressions,Coding  standards.
==============================================================================



COMPILER  DESIGN  USING  GDollar
--------------------------------

Introduction  of  Compiler Design
----------------------------------

What  is  Compiler?
-------------------

A   Translator    which  transforms    a  highlevel  language  such  as   CDollar, JDOLLAR,  C /C++,
Fortran  or  COBOL   into  a  Particular  computer  machine or  assembly  language
Is  called   a compiler.

What   is   Interpreter?
-------------------------
It  Process  an  internal form  of  the  source   program  and  data   at  a  same  time.
Ie,  interpretation of  the  internal  source  form    occurs  at run  time  and
No  object   program  is  generated.

A   compiler    must  perform   two  major  tasks.
a) Analysis   of  a  source   program  
b) Synthesis    of  a  corresponding  object  program

A)  Analysis    of  a  Source  program

a) Lexical   Analyser
------------------------------

That   we  know   Lexical  Analyser   is  responsible   for
Splitting    the    statements   into  tokens.
For  eg)  If  A >  B   then  is    splited   as
If    20
A  21
  >22
B   23
Then   24

Lexical  Analyzer  supplies   tokens  to  syntax
Analyzer.

b) SYNTAX   ANALYZER
------------------------------
IT's  function  is  to  take   the  source  program  from  lexical

Analyzer    and   determine   the  manner    in  which   it  is

Decomposed   into  constituent  parts.

Syntax    Analyser    outputs    a  syntax  tree   in   
Which  leaves   are  tokens  and  every  nonleaf  node  represents
A  syntactic  class  type.
SYNTACTIC  TREE   is     factor,  term  ,  expression.

Semantic  Analyser
------------------
It   is    main responsible  of  generation   of  intermediate   form  of  source  code.
Eg)
  (+ ,A,B,T1)
(+,C,D,t2)

The   output   of   semantic    Analyser  is  passed  to  code  Generator.

At   this  point  the  intermediate  form  of  the  source   program
is  usually    translated   to  either  assembly  language  or  machine   language.

The  Output   of  Code  Generator    is   passed   on to
a    code    Optimizer.

THE  CODE   OPTIMIZER
----------------------

The   Code    Optimizer   is  responsible   to  produce    a    object or   exe  or  class
Or   wl  files.


 ERROR  HANDLER
 ---------------
In compiler  design    Syntax   error  ,  invalid   characters,  out  of  memory  exception,
Checked    and   unchecked    exception    are     the    exception  occurs   if  a   new  
User    do  it. This    error   function  f(X)   is  to  determine  the   error    in source   code.
Without   error  handler   no  body   can  predict    the  errors..

SYMBOL  TABLE
-------------

A  Symbol   Table   will   contains  Variable  name,   Address, Type,  dimensions,  line  declared or  referenced,  and  pointer.
Mostly   commonly  performed   on   Symbol  table   are   insertion  and  Lookup.

STORAGE  ALLOCATION
--------------------

In  static    storage   allocation  strategy   it  is necessary   to be  able   to decide   at  compile  time
Exactly  where   each  object     will  reside    at  run time.
But  at   dynamic   storage   allocation   strategy   the  data    area  requirements   for  the  program
Are  not   known  entirely   at   compilation time.

Note: Parser  is    divided   in   to  topdown  parsing  and  bottom  up parsing.
That   you  refered    through   many   websites .
THE    GDollar    for    compiler   Design

GDollar   and  it's  ADVANTAGES
--------------------------------

What  is  GDollar?  Who invented   it?  Who  should  focus  it?
GDollar  Technology  is    meant    for    Developing   a   compiler
By    using    GDollar   Technology  and  its  DataStructures
which   saves  time   and  cost   and    years   ;
And    make     you    to  develop   a  compiler with   in   a  6  month.

GDollar   Technology   is  invented    by  wilmix  jemin j  in  cdollar at  first and
Fulfilled    at  year  2013  and  modified   at   C#  , JAVA , C/C++ P.L  at year  2016.

System  programmers,  Technology   inventors,  GDollar  Professionals,
And  professionals    who  are   interested   in  inventing   compiler
Should be  focused.





ABOUT GDollar
--------------

GDollar  is   an  Opensource  compiler   focused on  compiler  Design. GDollar belong  to  JAVA or  C#  or  C/C++  Group family.

GDollar is Invented in  JAVA, C#, C/C++.
GDollar virtual machine is used for 
GDollar to run  programs. G stands for Beta and Dollar stands for money.
So we called as Beta Technology.

GDollar  is  used   by  IT  companies   and  industries  in  the  world.

Syntax of GDollar:
------------------


<GDollar>

<USE> packages;

<%


<! OOPS statements  !>


%>


 ?>

 Merits of GDollar
 ------------------
> It is Good to create any compilers..

> It has simplified code

Demerits of GDollar:

It is not concenterated in creating Operating systems.
It is concenterated only in creating compilers.


How  to  compile  and  run   GDollar?

GDollarc <filename>.Gdollar



EXAMPLE:1: abc.Gdollar
---------

Regular  Expression  for  lexical  analysis and  sample  of  GDollar :
----------------------------------------------------------------




<GDollar>

<%



class Main1
{
 public  Main1()
 {
 <SUPER>();
 }

 public void main1()
 {
 
 String  s="dsdds";
 
 {*}<<Str>> l Pointer<<Str>>(s);  //store  s  in pointer
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.get(i); // get  string  from  pointer  and  print  it
 GDollar.Println(obj); //GDollar print  statement
 
 
 
 }
 
 
 
 
 <STRUCTURE> <<OBJECT>> list = <NEW> <STRUCTURE> <<OBJECT>>(l.get(0).StringConvert());  //use  structure  to store  the pointer  values 
 
 for (int i11 = 0; i11 NOT= list.size(); i11 = i11 + 1)
 {
 
 
 
 <OBJECT>  el=list.ret(i11); //  get  object  from  structures
 

 
 GDollar.Println("SNO= "+el.StringConvert());//  convert  object  to string  and print it.

                }
 
 }
}


   class  abc

{

 
public void  GDollar-Main()  //main  function  of   GDollar  program
{





Main1  m  = <NEW> Main1();

m.main1();

String line="IF (A>B) then";

String  expr="\\s+|\\)+|\\(";
GDollar.Println(""+compiler.REGEX( line,expr)); //pass  String  and  Regular  Expression  to split  it  int  to tokens

}

}


%>


 ?>



OUTPUT:
-------



Thu Nov 05 22:00:26 GMT+00:00 2015*CDollar: dsddsdsddsSNO= dsdds
TYPE   REGULAR   EXPRESSION[IF, , A>B, , then]


DATASTRUCTURES   for   GDollar
------------------------------

This   means   constructing   printf  statement,  scanf  statement...


Kindly  study   GDollar   Technology  before   go through  this  technology.


Scanf statement:
---------------

<GDollar>



<%
  
class Main
{
 public Main()
 {
 <SUPER>();
 }

 
}


class Scanf
{
 
 private Scanf nextNode = null;//This  line   creates  a  pointer   to  a  class 

 private String datum = null;

 public Scanf(String datum)
 {
 <SUPER>();
 <IS>.datum = datum;//assign  the   scanf  param  valaue
 }

 public void add(String datum)
 {
 if (nextNode NOT= null)
 {
 nextNode.add(datum); // nextNode.add(datum)  is  used  to  insert  many data....
 return;
 }

 nextNode = <NEW> Scanf(datum);
 }

 public String get(int i)
 {
 if (i == 0)
 return datum;

 return nextNode.get(i - 1);//get  the  i-1 value 
 }

 public int size()
 {
 if (nextNode == null)
 return 1;

 return nextNode.size() + 1; //increment  the  pointer
 }
 
 
 
 public void  GDollar-Main()
{

Scanf list = <NEW> Scanf("0 sheep");//pass  some  values  in  scanf  statement 
 list.add("1 horse");
 list.add("2 pig");
 list.add("3 cow");
 list.add("4 goat");
 list.add("5 chicken");
 list.add("6 ostrich");

 for (int i=0;i<=list.size()-1;i++)
 GDollar.Println(""+list.get(i));  //print  the  values
}
 
}







%>


?>




Printf statement datastructures:
--------------------------------


<GDollar>
<%
  
class Main
{
 public Main()
 {
 <SUPER>();
 }

 public void main1( )
 {
 Scanf l  =  <NEW> Scanf("wilmix");
 
 Printf list = <NEW> Printf("0 sheep");
 list.add(l.get(0).StringConvert());//print  the  first  value
 

 
 for (int i = 0; i NOT= list.size(); i = i + 1)
 {
 GDollar.Println(list.get(i));//print all  the  values
 GDollar.Println("\n");
 }
 }
}


class Printf  //same  thing   we  follow   in  scanf  statement
{
 
 private Printf nextNode = null;

 private String datum = null;

 public Printf(String datum)
 {
 <SUPER>();
 <IS>.datum = datum;
 }

 public void add(String datum)
 {
 if (nextNode NOT= null)
 {
 nextNode.add(datum);
 return;
 }

 nextNode = <NEW> Printf(datum);
 }

 public String get(int i)
 {
 if (i == 0)
 return datum;

 return nextNode.get(i - 1);
 }

 public int size()
 {
 if (nextNode == null)
 return 1;

 return nextNode.size() + 1;
 }
 
 
 
 
public void  GDollar-Main()
{

Main  m  = <NEW> Main();

m.main1();

} 

}
%>


?>


OUTPUT:
------



Thu Nov 05 23:21:10 GMT+00:00 2015*GDollar: 0 sheepwilmix



now  use this  scanf  and   printf   statement  in  GDollar  program...

what happens?



<GDollar>

<%




   class  abc1

{

 

public void  GDollar-Main()
{



Scanf l  =  <NEW> Scanf("wilmix");
 
 Printf list = <NEW> Printf("0 sheep");
 list.add(l.get(0).StringConvert());
 

 
 for (int i = 0; i NOT= list.size(); i = i + 1)
 {
 GDollar.Println(list.get(i));
 GDollar.Println("\n");
 }



}

}


%>


 ?>


 
 OUTPUT:
 ------
 
 
 
 Fri Nov 06 08:28:43 GMT+00:00 2015*
 
 GDollar: 0 sheepwilmix
 

What  happens?

It  generates  LinkedList  class file.



 Coding   Standards  of GDollar
 ------------------------------

<GDollar>
<USE> packages;

<%



 
 

%>

?> 
 
 
 Note : <%  and  %>   is  used   to  write   class   and  it's  logic.
 
 ALL  Program   should  Start   with  <GDollar>  means  starting  of   a  Program  and  succeded  by   <USE>
 
 to load  GDollar  packages  and   ?>  Means  End  of  the  Program.
 
 
 
 HIDE  Unwanted  code
 --------------------
 
 <------   program  code  ------>
 
 
 MAIN Program:
 -------------
 
 public void  GDollar-Main( )  indicates  MAIN  Program
 
 otherwise   it  will  not  run  the   Program
 
 
 STATIC  BLOCK
 -------------
 Shared  means   Static  keyword.
 
 Shared  will  be  executed  first   after that  Main program  will
 
 be  executed.
 
 
 
 Shared 
 
 {
 
 
 
 }
 
{}  =>  This  curly  braces  are mostly  used. 
 
 SOME  OPERATOR KEYWORDS
 -------------------------
 
 AND => &&  in  java
 
 NOT => !
 
 #  =>  !=
 
 
 
 NEW  Keyword
---------------

NEW  is  used  to create   an  instance   in  memmory.



Always  concenterate  on   important   keyword  not need  to
memmorize  at all.


DATATYPES:
-----------


int , char,  double  , float  are  ordinary keywords    of  oops

Programming  language like  C/JAVA/C#/CDollar.



STRUCTURES:
-----------

Always   use   Structure  DATATYPE to  store your  data  in  objects  form

so  that  it  will   reduce   the  storage  allocation   in memmory.

for  one  object  it  takes  only  1 byte of  memmory   for  structures.


GDollar(.g$)
------------

This  is    mostly   used  in  research   and   used  to construct  any  datastructure  and

simillar  to c.

RECYCLE:
-------

Always use  RECYCLE  to  make  the unwanted object  to  be    garbage  collected.



//
----


If  you want  to   describe  something about   your  functions

use  // . Don't  use  it  unnessary at  any way.



Special  Characters
--------------------

@,$%,^,[]  are  not  allowed   in  the GDollar  program


~ 
---

Use   Destructor  keyword  to  specify non GDollar  resource  deletion  code to 

be  goes when   you it..



Other  Things
-------------

for  loop  , if statements, while  loop, do  while ,

for each, Switch  statements, AutoBoxing , Generics , etc

are  same.

Did  GDollar  support pointer
-----------------------------


YES.

private Stacks nextNode =null;


consider  this  line  ;  This  line   creates  a  pointer   to  a  class  

Stacks . 


 nextNode=<NEW> Stacks(datum);
 
 This  statements  are   use  to insert first data  to Stacks

 nextNode.add(datum)  is  used  to  insert  many data....
 

 
 
Class   Inheritance
-------------------

If  the  Class  is  using  another  class  variable  in  that case

you  had  to  use   <---  "extends" backward arrows  
and  front  arrows -->    for  implements..

Implements  is  used   when  you  use  friend  function.

==============================================================================

UNIT-10:   G  D  O  L  L  A  R   ADVANCED  CONCEPTS  and  CJAVA
==============================================================================
UNION  IN GDollar

SYNTAX:
UNION  u =   new  UNION(string);
UNION  behave  like  structures   but  the  only  difference    is
Union has  build  in  functions like  
a)  Add(object)
b) Match(object,pos)
c)  ret(Object)
d) Size() of  object  

Advantages:
structures  is  not  used  in  the  comparision  of  values  so  union  is  used.

USECASE  in  GDollar

USECASE   <Object>  =  new  USECASE(datum);
datum  may  be  datatype
  eg)  integer   or  string
<OBJECT>.Loc1(ob)
<OBJECT>.Loc2(ob)

USECASE    behaves  like   UNION   and  is  used   for  storing 
objects   at  Loc1  ,Loc2  that  has  been   used  as  a   comparision   with  mathu1,matchu2 
respectively.
and  USECASE  uses   swithcase  statement    to  asign   values 
 

ADVANTAGES:

i)  Behave like  struct
ii)  compare   the  object
iii)  Used  for  storing  objects.
iV)    it  uses   switch  case  statement

LOOP statement in  GDollar:
SYNTAX:

LOOP   <Object>  =  new  LOOP(datum);
datum  may  be  datatype
  eg)  integer   or  string
<OBJECT>.Loc1(ob)
<OBJECT>.Loc2(ob)


LOOP    behaves  like   UNION   and  is  used   for  storing 
objects   at  Loc1  ,Loc2  that  has  been   used  as  a   comparision   with  mathu1,matchu2 
respectively.

ADVANTAGES:

i)  Behave like  struct
ii)  compare   the  object
iii)  Used  for  storing  objects.

BOOK  in  GDollar
SYNTAX:


BOOK  <OBJECT>=   new  BOOK(string);
<OBJECT>.STOREA(object,object);
<OBJECT>.STOREB(object,object);

It  is   used    for  storing   object      with  key  and  value   in  STOREA  and  STOREB.
And  it  is  used  to  compare  with  match  statement

ADVANTAGES
i)  Book   is  used   for  storing  two  block    of  pages.
ii) it  is    used   in  case  of  storing  large   amount  of  notes  and
it  is   used  with   database.

NOTE:
Examples   for  GDollar  Advanced  Datastructures   is  given  in
AdvancedDatastructures   folders   of   GDollar  Software.
GDollar  is  powerful   than   CDollar.

How   to compile   using  GDollar  and   see   the  output?
GDollarc  <filename>.Gdollar




==================================================================================

      ******* E N D   O F   G D O L L A R   PART1 C O N C E P T ****

===============================================================


Note:  This  GDollar - Tutorial- EXERCISES   is  a  Practical  Exercises    for GDollar  Programmers  we  can  use  GDollar-LIB DLL     in  GDollar   main  program.
Note:  PDF   is  under   construction if   you  learn   GDollar  PDF  you  can  learn  it  more  depth.
================================================================
           Jemin Information Technology  ---  Copyright @  2016   All  Rights  reserved
===============================================================
