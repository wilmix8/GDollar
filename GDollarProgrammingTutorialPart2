                                              CDOLLAR  Programming  Language (GDOLLAR  PART2)

                                                         BY

                                                  Jemin  Information   Technology
                                                     
==================================================================

CDollar Programming Language  is a modern technology consists of JAVA OOPS, Behave
like C/C++ OOPS, Networking, RUN and compile at same time,used in Software
Development  ,Research, and ,Advanced OOPs.
It  is  mainly  used  in software  field.
It is used in case of Billing,Forms ,Constructing Datastructures ,
Reports,Security,and,complex problems.
Note:  CDollar  programming  language  is  belong   to  GDollar  Technology section.


ABOUT CDOLLAR Programming Language
---------------------------------------------------
CDollar first name is "OLIVE Technology" which represents OLIVE TREE . Olive Technology
is renamed as CDOLLAR.
CDollar v.3 is invented in C/C++ and Java.
But also uses Attractive Syntax .
The CDollar is classified into extension which is

a).cdollar(simillar to java and C++ combination).
b) .C$ (For Intermediate code)
c) CWE-.cdollar  to   produce  Prototype  files
 e) CDollar Unix  => for  running  the  program  in  unix  Os.
f) CDollar  with  C#
g) CJAVA

So  Cdollar is   Platform  independant Language.

SYNTAX FOR CDOLLAR (.cdollar) (beautiful syntax)
---------------------------------------------------------------
<CDollar>
<IMPORT>
<%
<! CDollar OOPS Logic !>
%>
?>
note: This should be saved in filename.cdollar
----

How Cdollar Technology Works?
––––––––––––––––––––––––––––––––-
At first .cdollar is compiled by Cdollarc compiler
And it translate to .C$ file with intermediate code  that  hacker can't  understood.
Cdollarv.4 translator uses CDC friend compiler Which compiles
the Cdollar program.
After that Cdollarv.4 translates to .wl class files and use
CDRUN filename.wl automatically to run the Program.
So converting the bytes codes in .wl class file makes the progam
to run faster than other compilers..
============================================================
CDollarv.4
----------
We know that CDollarc is the compiler, But CDollarv.4 is a translator which translates
your program to .wl files or .Exe files...
This .wl files are futhure use.
CDollarv.4 version is focused on windows...

How to compile cdollar Program in windows?
Cdollarc <filename.cdollar>
How to run cdollar Program in windows?
CDRUN filename



==================================================================================
C D O L L A R -PROGRAMMING-TUTORIAL
--------------------------------------------------
Written By
wilmix jemin j
==================================================================================
UNIT -1
--------
INTRODUCTION
------------
Why CDollar?
-------------
CDollar is used for creating libraries ; CDollar is formed in C/C++
in year 2004.
CDollar is modified in java technology in year 2013, 2015,2016.
CDollar is the combination of JAVA , C/C++, and Advanced OOPS.
it will only accept the shortest attractive syntax.
CDollar first name is "OLIVE Technology" which represents OLIVE TREE . Olive Technology
is renamed as CDOLLAR.
Note: a) The Meaning of CDollar is combination of C++ and JAVA OOPS
concepts.
c) CDollar version 1 contains a build compiler .cdollar.
where .cdollar has the features like java,C# , and C/C++.

SYNTAX-1 (used only for CWEB - .cdollar)
------------------------------------------------------------
<CDollar>
<USE> packages;
<%
<! CDollar-.cdollar OOPS Logic and main functions !>
%>
?>
How CDollar is formed ? What are its Advantages Over Native language JAVA Programming?
--------------------------------------------------------------------------------------------------------------
CDollar is formed in C++ OOPS concepts..
JAVA borrowed C++ OOPS concepts but
CDollar borrowed C++ OOPS concepts and JAVA oops and it has
Attractive syntax ; Plus in-build functions
for Program and it is responsible for creating
libraries (.wl). JAVA has attained the Programming
standards, But CDollar attains combination of C Technology
and JAVA Technology advantages.
CDollar Generates .wl class files
but JAVA Generated .class files.
Cdollar Has Advanced OOPS than JAVA 1.8.

Program-1: abc1.cdollar

<CDollar> 
 
<%
class LL1 
{ 
private LL1 nextNode = null; 
private String datum = null; 
public LL1() 
{ 
LL1 list = <NEW> LL1("0 C"); 
list.add("1 CDOLLAR"); 
list.add("2 GDOLLAR"); 
list.add("3 CHDOLLAR"); 
list.add("4 JDOLLAR"); 
list.add("5 JSTAR"); 
list.add("6 JSAUCER"); 
for (int i = 0; i NOT= list.size(); i = i + 1) 
{ 
CDollar.out.println(""+list.get(i).StringConvert()); 
} 
} 
public LL1(String datum) 
{ 
<SUPER>(); 
<IS>.datum = datum; 
} 
public void add(String datum) 
{ 
if (nextNode NOT= null) 
{ 
nextNode.add(datum); 
return; 
} 
nextNode = <NEW> LL1(datum); 
} 
public String get(int i) 
{ 
if (i == 0) 
return datum; 
return nextNode.get(i - 1); 
} 
public int size() 
{ 
if (nextNode == null) 
return 1; 
return nextNode.size() + 1; 
} 
} 
class abc1 
{ 
public void  CDOLLAR-Main( )
{ 
int i; 
CDollar.out.println("\nList of Technologies in year "+"2016 "); 
LL1 list = <NEW> LL1(); 
String i1="weew"; 
CDollar.out.println("wilmix"+i1); 
CDollar.out.println(" \njemin"+"is going"); 
} 
} 
%>
?>

How  to compile  it?
CDollarc  abc1.cdollar

How  to  run  CDollar  and  see  the  output  stored  in  .wl file?

K:\CDollar>CDRUN abc1

<table bgcolor=green>
<td>List of Technologies in year 2016 0 C1 CDOLLAR2 GDOLLAR3 CHDOLLAR4 JDOLLAR5
JSTAR6 JSAUCERwilmixweew jeminis going<td>
</table>

List of Technologies in year 2016 0 C1 CDOLLAR2 GDOLLAR3 CHDOLLAR4 JDOLLAR5 JSTA
R6 JSAUCERwilmixweew jeminis going

Program -2: Abc5.cdollar


<CDollar>
<%

abstract  class  Abc51

{

  abstract void display();

}

public  class  Abc5  <--- Abc51 

{
 Shared void display()
{
CDollar.out.println("Wilmix"+"jemin");
}
 public void  CDOLLAR-Main( )

{
display();

}
}
%>

?>
How  to compile  it?
CDollarc  abc1.cdollar

Output:
When  you run  using  CDRUN....
K:\CDollar>CDRUN abc1
you  will   get  a   error  ....
how  you  find   error?
type  out.txt  in command prompt

K:\CDollar>type  out.txt
Abc5.:30: error: display() in Abc5 cannot override display() in Abc51
 static void display()
             ^
  overriding method is static
1 error

Program-3: abcd.cdollar

<CDollar>
<%
class   abc
{

void  display(String s)

{

CDollar.out.println("We  learn  C ,  Dotnet  ,and  ,CDollar");
}

}

class    abcd    <---  abc

{

void  display(String s)
{
<SUPER>(s);  
CDollar.out.println("We  learn  C ,  Dotnet  ,and  ,JDollar");
}
}
%>
?>


K:\CDollar>type out.txt
abcd:30: error: call to super must be first statement in constructor
super(s);
     ^
1 error


A.cdollar
<CDollar>

<%

  class A
{

  public A()  { CDollar.out.println("A's  called"+"n"); }
}
 
class B
{
public B()  { CDollar.out.println("B's  called"+"n"); }
}
 
public class C 
{
public C()  { { CDollar.out.println("C's  called"+"n"); } }

 
public void  CDOLLAR-Main( ) throws <EXE>
{
    <NEW> A();
    <NEW> B();
    <NEW> C();
}
}

%>
?>
Input:
CDollarc  A.cdollar

Output:
K:\CDollar>CDRUN C
<table bgcolor=green>
<td>A's  callednB's  callednC's  calledn<td>

</table>
A's  callednB's  callednC's  calledn

concat.cdollar

<CDollar>
<USE> <CJAVA>.io.*;
<USE> <CJAVA>.util.*;
<%
// Advanced concepts : Here Friends is a helper function used in other classes
friends toy
{
public void display();
}
// friends will act like friend function in C++.
class concat1 --> toy
//---> indicates implements toy
{
public void display()
{
CDollar.out.println("CDollar is going to be finished");
}
}
public class concat
{
Shared int counter=4;
//Shared means static and which can be accessed over all the objects of
variables.
//<EXE> means throws Exception
// <S> means set
//<WR> indicates iterator
//<SBD> means string builder
//<SB> is String Buffer
// Differences is StringBuffer is Synchronized and
//and String Builder is not Synchronized
//AND means && in JAVA
//NOT means ! in JAVA
//TH means Thread in CDollar
//int <Arrayname> Array [nooflocations] (ARRAY SYNTAX)
//addE means AddElements
public  Shared void  LIB( ) throws <EXE>
{
int i;
String i1="weew";
Print.Println("wilmix",i1);
Print.Println(" \njemin","is going");
<S> <Integer> ar2 = <NEW> <TS> <Integer> ();
ar2.add(100);
<WR> it = ar2.record();
while (it.<HAS>)
{
<OBJECT> el= it.next();
Print.Println("/n",el.StringConvert());
}
<SBD> sb = <NEW> <SBD>("weldone wilmix");
int a;
a=105;
if (( a >100) AND (a<=106))
CDollar.out.println("/n"+a);
if (a NOT= 0)
CDollar.out.println("/n"+a);
a+=2+counter;
if (a # 107)
CDollar.out.println("/n"+a);
TH t = <NEW> TH();
int a11[] <Array> int[100];
a11[0]=1000;
CDollar.out.println("/n"+a11[0]);
<VList> v = <NEW> <VList>();
v.addE(100);
CDollar.out.println("/n"+v.get(0));
v.removeAt(0);
v.addE(1001);
v.addE(1002);
CDollar.out.println("/n"+v.first());
// This is the program for writing program in random access file ;
//it means it can be randomly inserted and retrieved at any location */
//writing word in random accessfile
<RANDOMACCESSFILE> rf = <NEW> <RANDOMACCESSFILE>("concat.c$","rw");
rf.write("Hello World".getBytes());
rf.close();
rf.close();
concat1 obj = <NEW> concat1();
obj.display();
}
}
%>
?>
Compile:
CDollarc  concat.cdollar

So What will be the Output?

K:\CDollar>CDRUN concat
<table bgcolor=green>
<td>wilmixweew  jeminis going/n100/n105/n105/n111/n1000/n100/n1001<td>
</table>
wilmixweew  jeminis going/n100/n105/n105/n111/n1000/n100/n1001

Duplicates.cdollar

<CDollar>
<USE> <CJAVA>.util.*;
<%
 public class Duplicates {
 
  public void  CDOLLAR-Main( ) throws  <EXE>

{
         
        <S><Emp> ts = <NEW> Tree<S><Emp>(<NEW> EmpComp());
        ts.add(<NEW> Emp(201,"John",40000));
        ts.add(<NEW> Emp(302,"Krish",44500));
        ts.add(<NEW> Emp(146,"Tom",20000));
        ts.add(<NEW> Emp(543,"Abdul",10000));
        ts.add(<NEW> Emp(12,"Dinesh",50000));
        //adding duplicate entry
        ts.add(<NEW> Emp(146,"Tom",20000));

        ts.add(<NEW> Emp(7777,"777",7777777));
        //check duplicate entry is there or not
        for(Emp e:ts){
            CDollar.out.println(e);
        }
    }
}
 
class EmpComp --> Comparator<Emp>{
 
    @Override
    public int compare(Emp e1, Emp e2) {
        if(e1.getEmpId() == e2.getEmpId()){
            return 0;
        } if(e1.getEmpId() < e2.getEmpId()){
            return 1;
        } else {
            return -1;
        }
    }
}
 
class Emp {
     
    private int empId;
    private <Str> empName;
    private int empSal;
     
    public Emp(int id, <Str> name, int sal){
        <IS>.empId = id;
        <IS>.empName = name;
        <IS>.empSal = sal;
    }
     
    public int getEmpId() {
        return empId;
    }
     
    public void <S>EmpId(int empId) {
        <IS>.empId = empId;
    }
     
    public <Str> getEmpName() {
        return empName;
    }
     
    public void <S>EmpName(<Str> empName) {
        <IS>.empName = empName;
    }
     
    public int getEmpSal() {
        return empSal;
    }
    public void <S>EmpSal(int empSal) {
        <IS>.empSal = empSal;
    }
     
    public <Str> to<Str>(){
        return empId+" : "+empName+" : "+empSal;
    }
}

%>


?>
Compile using  Duplicates.cdollar

Output:
G:\CDollar>CDRUN Duplicates
<table bgcolor=green>
<td>7777 : 777 : 7777777543 : Abdul : 10000302 : Krish : 44500201 : John : 40000
146 : Tom : 2000012 : Dinesh : 50000<td>

</table>
7777 : 777 : 7777777543 : Abdul : 10000302 : Krish : 44500201 : John : 40000146
: Tom : 2000012 : Dinesh : 50000


GEN.cdollar

<CDollar>
<%
  public class  GEN<T>
  
  {
  T t;
  T  display(T  t1)
  
  {
  
  t=t1;
  return(t);
 
  
  }
  
  
  public void  CDOLLAR-Main( )
  
  {
  
  GEN <Integer> i  = <NEW>  GEN<Integer> ();
  
 CDollar.out.println(""+ i.display(10)); 
  }
 
  }

%>

?>


F1:\CDollar>CDRUN GEN
<table bgcolor=green>
<td>10<td>

</table>
10

Geometry.cdollar

<CDollar>
<%

class Polygon {
  Shared int width, height;
  public Shared int s_values (int a, int b)
      { width=a; height=b; return(0); }
}

class Rectangle  <--- Polygon {
  public int area()
      { return width*height; }
}

class Triangle  <--- Polygon {
  public int area()
      { return width*height/2; }
}

class  Geome<TRY>{
 public void  CDOLLAR-Main( ) {
  Rectangle rect = <NEW>  Rectangle();
  Triangle trgl= <NEW> Triangle();
  
  int t= Polygon.s_values (4,5)  * Polygon.s_values (4,5);
  CDollar.out.println( "Rect area="+rect.area());
  CDollar.out.println( "Triange  Area="+trgl.area());
  
}
}
%>



?>

F1:\CDollar>CDRUN Geometry
<table bgcolor=green>
<td>Rect area=20Triange  Area=10<td>

</table>
Rect area=20Triange  Area=10

misc.cdollar

<CDollar>

<USE> <CJAVA>.util.*;




<%
  abstract class  misc <--- TH 

{

<VOLATILE> int v1; //synchronized  happen  at variable level
Shared <TRANS> int v;



~ //destructor in  cdollar
{

CDollar.out.println("object  is    deleted");

}
public  int  getnum1()

{



return(v1);
}

Shared int s3;
public Shared void  operator *(int s1 ,int s2)
{

s3=s1 * s2;

CDollar.out.println(""+s3);
}

 public void  CDOLLAR-Main( ) throws  <EXE>
{

int  a[]  <Array> int[1000];


 operator *(10,10);//operator overloading
 
 operator *(200,10000);//operator overloading



<AList>  ar  = <NEW>  <AList>();



for(int  i=999;i>=0;i--)
{

a[i]=i;

ar.add(i);
}

<A>.<SORT>(a);



CDollar.out.println(" binary "+<A>.<BinarySearch>(a,5));//perform  binary search and  element  5  occurs  at  5th location



<WR>  it  =  ar.record();


while(it.<HAS>)

{
<OBJECT>  el   =  it.<NEXT>;

CDollar.out.println(" data= "+el);


}
<LR>  it1  =  ar.<LISTLR>;
while(it1.<HASP>)

{
<OBJECT>  el1   =  it1.<PREVIOUS>;//move  previous

CDollar.out.println(" data1= "+el1);
}



<------
while  (es.<HASEMORE>)

{

<OBJECT>  el11   =  es.<NEXTEL>;

CDollar.out.println(" data1= "+el1);
}
------>


<DATE>  d2  =   <NEW>  <DATE>();


CDollar.out.println("month="+<Month>);
CDollar.out.println("Year="+<Y>);
CDollar.out.println("Hour="+<H>);
CDollar.out.println("Sec="+<SEC>);



v=20;

<FOUTPUTSTREAM> os1  =  <NEW>  <FOUTPUTSTREAM>("out11.txt");
<OOUTPUTSTREAM> d  =  <NEW> <OOUTPUTSTREAM>(os1);

d.<WRITEOBJ>(v);// v is  transient  so it is  saved.
d.<WRITEOBJ>(ar);//ar  is  not  transient  so  not saved

<FINPUTSTREAM> osd  =  <NEW>  <FINPUTSTREAM>("out11.txt");
<OINPUTSTREAM>  br  =  <NEW>  <OINPUTSTREAM>(osd);

<OBJECT>  ar7  =  br.<OBJECTREAD>;

CDollar.out.println("data="+ar7);


<STACK> s=  <NEW>  <STACK>();

s.<PUSH>(100);
s.<PUSH>(2000);
s.<POP>;

CDollar.out.println("stackdata="+s);


<PRIORITYQUEUE>  q =  <NEW>  <PRIORITYQUEUE>();

q.add(1000);

q.add(544);
q.add(66);
q.add(667888);
CDollar.out.println(""+q);




}





}


%>


?>



Output:
1002000000 binary 5 data= 999 data= 998 data= 997 data= 996 data= 995 data= 994
data= 993 data= 992 data= 991 data= 990 data= 989 data= 988 data= 987 data= 986
data= 985 data= 984 data= 983 data= 982 data= 981 data= 980 data= 979 data= 978
data= 977 data= 976 data= 975 data= 974 data= 973 data= 972 data= 971 data= 970
data= 969 data= 968 data= 967 data= 966 data= 965 data= 964 data= 963 data= 962
data= 961 data= 960 data= 959 data= 958 data= 957 data= 956 data= 955 data= 954
data= 953 data= 952 data= 951 data= 950 data= 949 data= 948 data= 947 data= 946
data= 945 data= 944 data= 943 data= 942 data= 941 data= 940 data= 939 data= 938
data= 937 data= 936 data= 935 data= 934 data= 933 data= 932 data= 931 data= 930
data= 929 data= 928 data= 927 data= 926 data= 925 data= 924 data= 923 data= 922
data= 921 data= 920 data= 919 data= 918 data= 917 data= 916 data= 915 data= 914
data= 913 data= 912 data= 911 data= 910 data= 909 data= 908 data= 907 data= 906
data= 905 data= 904 data= 903 data= 902 data= 901 data= 900 data= 899 data= 898
data= 897 data= 896 data= 895 data= 894 data= 893 data= 892 data= 891 data= 890
data= 889 data= 888 data= 887 data= 886 data= 885 data= 884 data= 883 data= 882
data= 881 data= 880 data= 879 data= 878 data= 877 data= 876 data= 875 data= 874
data= 873 data= 872 data= 871 data= 870 data= 869 data= 868 data= 867 data= 866
data= 865 data= 864 data= 863 data= 862 data= 861 data= 860 data= 859 data= 858
data= 857 data= 856 data= 855 data= 854 data= 853 data= 852 data= 851 data= 850
data= 849 data= 848 data= 847 data= 846 data= 845 data= 844 data= 843 data= 842
data= 841 data= 840 data= 839 data= 838 data= 837 data= 836 data= 835 data= 834
data= 833 data= 832 data= 831 data= 830 data= 829 data= 828 data= 827 data= 826
data= 825 data= 824 data= 823 data= 822 data= 821 data= 820 data= 819 data= 818
data= 817 data= 816 data= 815 data= 814 data= 813 data= 812 data= 811 data= 810
data= 809 data= 808 data= 807 data= 806 data= 805 data= 804 data= 803 data= 802
data= 801 data= 800 data= 799 data= 798 data= 797 data= 796 data= 795 data= 794
data= 793 data= 792 data= 791 data= 790 data= 789 data= 788 data= 787 data= 786
data= 785 data= 784 data= 783 data= 782 data= 781 data= 780 data= 779 data= 778
data= 777 data= 776 data= 775 data= 774 data= 773 data= 772 data= 771 data= 770
data= 769 data= 768 data= 767 data= 766 data= 765 data= 764 data= 763 data= 762
data= 761 data= 760 data= 759 data= 758 data= 757 data= 756 data= 755 data= 754
data= 753 data= 752 data= 751 data= 750 data= 749 data= 748 data= 747 data= 746
data= 745 data= 744 data= 743 data= 742 data= 741 data= 740 data= 739 data= 738
data= 737 data= 736 data= 735 data= 734 data= 733 data= 732 data= 731 data= 730
data= 729 data= 728 data= 727 data= 726 data= 725 data= 724 data= 723 data= 722
data= 721 data= 720 data= 719 data= 718 data= 717 data= 716 data= 715 data= 714
data= 713 data= 712 data= 711 data= 710 data= 709 data= 708 data= 707 data= 706
data= 705 data= 704 data= 703 data= 702 data= 701 data= 700 data= 699 data= 698
data= 697 data= 696 data= 695 data= 694 data= 693 data= 692 data= 691 data= 690
data= 689 data= 688 data= 687 data= 686 data= 685 data= 684 data= 683 data= 682
data= 681 data= 680 data= 679 data= 678 data= 677 data= 676 data= 675 data= 674
data= 673 data= 672 data= 671 data= 670 data= 669 data= 668 data= 667 data= 666
data= 665 data= 664 data= 663 data= 662 data= 661 data= 660 data= 659 data= 658
data= 657 data= 656 data= 655 data= 654 data= 653 data= 652 data= 651 data= 650
data= 649 data= 648 data= 647 data= 646 data= 645 data= 644 data= 643 data= 642
data= 641 data= 640 data= 639 data= 638 data= 637 data= 636 data= 635 data= 634
data= 633 data= 632 data= 631 data= 630 data= 629 data= 628 data= 627 data= 626
data= 625 data= 624 data= 623 data= 622 data= 621 data= 620 data= 619 data= 618
data= 617 data= 616 data= 615 data= 614 data= 613 data= 612 data= 611 data= 610
data= 609 data= 608 data= 607 data= 606 data= 605 data= 604 data= 603 data= 602
data= 601 data= 600 data= 599 data= 598 data= 597 data= 596 data= 595 data= 594
data= 593 data= 592 data= 591 data= 590 data= 589 data= 588 data= 587 data= 586
data= 585 data= 584 data= 583 data= 582 data= 581 data= 580 data= 579 data= 578
data= 577 data= 576 data= 575 data= 574 data= 573 data= 572 data= 571 data= 570
data= 569 data= 568 data= 567 data= 566 data= 565 data= 564 data= 563 data= 562
data= 561 data= 560 data= 559 data= 558 data= 557 data= 556 data= 555 data= 554
data= 553 data= 552 data= 551 data= 550 data= 549 data= 548 data= 547 data= 546
data= 545 data= 544 data= 543 data= 542 data= 541 data= 540 data= 539 data= 538
data= 537 data= 536 data= 535 data= 534 data= 533 data= 532 data= 531 data= 530
data= 529 data= 528 data= 527 data= 526 data= 525 data= 524 data= 523 data= 522
data= 521 data= 520 data= 519 data= 518 data= 517 data= 516 data= 515 data= 514
data= 513 data= 512 data= 511 data= 510 data= 509 data= 508 data= 507 data= 506
data= 505 data= 504 data= 503 data= 502 data= 501 data= 500 data= 499 data= 498
data= 497 data= 496 data= 495 data= 494 data= 493 data= 492 data= 491 data= 490
data= 489 data= 488 data= 487 data= 486 data= 485 data= 484 data= 483 data= 482
data= 481 data= 480 data= 479 data= 478 data= 477 data= 476 data= 475 data= 474
data= 473 data= 472 data= 471 data= 470 data= 469 data= 468 data= 467 data= 466
data= 465 data= 464 data= 463 data= 462 data= 461 data= 460 data= 459 data= 458
data= 457 data= 456 data= 455 data= 454 data= 453 data= 452 data= 451 data= 450
data= 449 data= 448 data= 447 data= 446 data= 445 data= 444 data= 443 data= 442
data= 441 data= 440 data= 439 data= 438 data= 437 data= 436 data= 435 data= 434
data= 433 data= 432 data= 431 data= 430 data= 429 data= 428 data= 427 data= 426
data= 425 data= 424 data= 423 data= 422 data= 421 data= 420 data= 419 data= 418
data= 417 data= 416 data= 415 data= 414 data= 413 data= 412 data= 411 data= 410
data= 409 data= 408 data= 407 data= 406 data= 405 data= 404 data= 403 data= 402
data= 401 data= 400 data= 399 data= 398 data= 397 data= 396 data= 395 data= 394
data= 393 data= 392 data= 391 data= 390 data= 389 data= 388 data= 387 data= 386
data= 385 data= 384 data= 383 data= 382 data= 381 data= 380 data= 379 data= 378
data= 377 data= 376 data= 375 data= 374 data= 373 data= 372 data= 371 data= 370
data= 369 data= 368 data= 367 data= 366 data= 365 data= 364 data= 363 data= 362
data= 361 data= 360 data= 359 data= 358 data= 357 data= 356 data= 355 data= 354
data= 353 data= 352 data= 351 data= 350 data= 349 data= 348 data= 347 data= 346
data= 345 data= 344 data= 343 data= 342 data= 341 data= 340 data= 339 data= 338
data= 337 data= 336 data= 335 data= 334 data= 333 data= 332 data= 331 data= 330
data= 329 data= 328 data= 327 data= 326 data= 325 data= 324 data= 323 data= 322
data= 321 data= 320 data= 319 data= 318 data= 317 data= 316 data= 315 data= 314
data= 313 data= 312 data= 311 data= 310 data= 309 data= 308 data= 307 data= 306
data= 305 data= 304 data= 303 data= 302 data= 301 data= 300 data= 299 data= 298
data= 297 data= 296 data= 295 data= 294 data= 293 data= 292 data= 291 data= 290
data= 289 data= 288 data= 287 data= 286 data= 285 data= 284 data= 283 data= 282
data= 281 data= 280 data= 279 data= 278 data= 277 data= 276 data= 275 data= 274
data= 273 data= 272 data= 271 data= 270 data= 269 data= 268 data= 267 data= 266
data= 265 data= 264 data= 263 data= 262 data= 261 data= 260 data= 259 data= 258
data= 257 data= 256 data= 255 data= 254 data= 253 data= 252 data= 251 data= 250
data= 249 data= 248 data= 247 data= 246 data= 245 data= 244 data= 243 data= 242
data= 241 data= 240 data= 239 data= 238 data= 237 data= 236 data= 235 data= 234
data= 233 data= 232 data= 231 data= 230 data= 229 data= 228 data= 227 data= 226
data= 225 data= 224 data= 223 data= 222 data= 221 data= 220 data= 219 data= 218
data= 217 data= 216 data= 215 data= 214 data= 213 data= 212 data= 211 data= 210
data= 209 data= 208 data= 207 data= 206 data= 205 data= 204 data= 203 data= 202
data= 201 data= 200 data= 199 data= 198 data= 197 data= 196 data= 195 data= 194
data= 193 data= 192 data= 191 data= 190 data= 189 data= 188 data= 187 data= 186
data= 185 data= 184 data= 183 data= 182 data= 181 data= 180 data= 179 data= 178
data= 177 data= 176 data= 175 data= 174 data= 173 data= 172 data= 171 data= 170
data= 169 data= 168 data= 167 data= 166 data= 165 data= 164 data= 163 data= 162
data= 161 data= 160 data= 159 data= 158 data= 157 data= 156 data= 155 data= 154
data= 153 data= 152 data= 151 data= 150 data= 149 data= 148 data= 147 data= 146
data= 145 data= 144 data= 143 data= 142 data= 141 data= 140 data= 139 data= 138
data= 137 data= 136 data= 135 data= 134 data= 133 data= 132 data= 131 data= 130
data= 129 data= 128 data= 127 data= 126 data= 125 data= 124 data= 123 data= 122
data= 121 data= 120 data= 119 data= 118 data= 117 data= 116 data= 115 data= 114
data= 113 data= 112 data= 111 data= 110 data= 109 data= 108 data= 107 data= 106
data= 105 data= 104 data= 103 data= 102 data= 101 data= 100 data= 99 data= 98 da
ta= 97 data= 96 data= 95 data= 94 data= 93 data= 92 data= 91 data= 90 data= 89 d
ata= 88 data= 87 data= 86 data= 85 data= 84 data= 83 data= 82 data= 81 data= 80
data= 79 data= 78 data= 77 data= 76 data= 75 data= 74 data= 73 data= 72 data= 71
 data= 70 data= 69 data= 68 data= 67 data= 66 data= 65 data= 64 data= 63 data= 6
2 data= 61 data= 60 data= 59 data= 58 data= 57 data= 56 data= 55 data= 54 data=
53 data= 52 data= 51 data= 50 data= 49 data= 48 data= 47 data= 46 data= 45 data=
 44 data= 43 data= 42 data= 41 data= 40 data= 39 data= 38 data= 37 data= 36 data
= 35 data= 34 data= 33 data= 32 data= 31 data= 30 data= 29 data= 28 data= 27 dat
a= 26 data= 25 data= 24 data= 23 data= 22 data= 21 data= 20 data= 19 data= 18 da
ta= 17 data= 16 data= 15 data= 14 data= 13 data= 12 data= 11 data= 10 data= 9 da
ta= 8 data= 7 data= 6 data= 5 data= 4 data= 3 data= 2 data= 1 data= 0month=2Year
=1Hour=10Sec=13data=20stackdata=[100][66, 1000, 544, 667888] 


Program1.cdollar

<CDollar>


<USE> <CJAVA>.util.*;


<%



class  Program1 

{

 
 public void  CDOLLAR-Main( )
{

int i;
CDollar.out.println("\nList  of   Technologies  in  year "+"2016 ");	
	


String i1="weew";
CDollar.out.println("wilmix"+i1);

CDollar.out.println("Hiram is going"+"today");
CDollar.out.println("Hiram  Age  is ="+"45 ");

CDollar.out.println("Hiram    is working "+"in  Abc Bank\n");
CDollar.out.println("  \njemin"+"is going");

<TS>   ar2 =  <NEW>  <TS>();

ar2.add("100");
ar2.add("22");

CDollar.out.println("jeminjhjhjh"+ar2.StringConvert());

CDollar.out.println("no:  2/782 ,ds street,california-2322"+ar2.StringConvert());

		
		
		

}


}


%>


?>

output:

List  of   Technologies  in  year 2016 wilmixweewHiram is goingtodayHiram  Age
is =45 Hiram    is working in  Abc Bank  jeminis goingjeminjhjhjh[100, 22]no:  2
/782 ,ds street,california-2322[100, 22]


student.cdollar

<CDollar>
<%

public  class  student

{

Shared int  sno; Shared int  m1,m2,m3;

Shared double  avg=0.0;
  public void  CDOLLAR-Main( )
	{


student   s  =  <NEW>  student();

sno=1;

m1=234;
m2=456;
m3=656;

avg=((m1=m2+m3)/3);

CDollar.out.println(""+avg);

}
}

%>


?>

Output:
<table bgcolor=green>
<td>370.0<td>

</table>
370.0


TA.cdollar

<CDollar>
<%
class Person {
   // Data members of person
   
   Person(){}
public Person(int x)  { CDollar.out.println("Person::Person(int ) called"+x);   }
}
 
class Faculty  {

public Faculty(int x)

{

<NEW> Person(x);
       CDollar.out.println("Faculty::Faculty(int ) called"+x);
    }
}
 
 
class Student  {
   // data members of Student
public  Student(int x) {
<NEW> Person(x);
        CDollar.out.println("Student::Student(int ) called"+ x);
    }
}


 
class TA   {
    TA(int x)  {
    <NEW> Faculty(x);
    <NEW>  Student(x);
   
        
    CDollar.out.println("TA::TA(int ) called"+x);



    }
     
 
 public void  CDOLLAR-Main( )
{
    <NEW>  TA(30);


}

}
%>



?>

OUTPUT:
<table bgcolor=green>
<td>Person::Person(int ) called30Faculty::Faculty(int ) called30Person::Person(i
nt ) called30Student::Student(int ) called30TA::TA(int ) called30<td>

</table>
Person::Person(int ) called30Faculty::Faculty(int ) called30Person::Person(int )
 called30Student::Student(int ) called30TA::TA(int ) called30

threads.cdollar

<CDollar>

<%
  
 class threads

{

    public void  CDOLLAR-Main( ) 

    {

        My thread1 = <NEW> My("thread1: ");

        My thread2 = <NEW> My("thread2: ");

        thread1.<START>;

        thread2.<START>;

        boolean thread1IsAlive = true;

        boolean thread2IsAlive = true;

        do {

           if (thread1IsAlive AND NOTthread1.isAlive()) {

               thread1IsAlive = false;

              CDollar.out.println("MY   DOG 1 is dead.");

           }

           if (thread2IsAlive AND NOTthread2.isAlive()) {

               thread2IsAlive = false;

               CDollar.out.println("MY  DOG 2 is dead.");

           }

        } while(thread1IsAlive || thread2IsAlive);

    }

}

 

class My <--- TH

{

Shared <Str> message[] ={ "CDollar", "is", "combination", "of", "JAVA", "and   c"};

 

    public My(<Str> id)

    {

        <SUPER>(id);

    }

 

    public void <RUN>

    {

        SyncOut.displayList("welcome",message);

    }

 

    void randomWait()

    {

        <TRY> {

         <SLEEP>((long)(3000*Math.random()));

        } <CATCH> (<EXE> x) {

           CDollar.out.println("Interrupted!");

        }

    }

}

 

class SyncOut

{

public Shared  void displayList(<Str> name,<Str> list[])

{

for(int i=0;i<list.length;++i) {

My t = (My) TH.currentTH();

t.randomWait();

CDollar.out.println(name+list[i]);

}

}

} 


  
  


%>


?>



OUTPUT:

<table bgcolor=green>
<td>welcomeCDollarwelcomeiswelcomeCDollarwelcomecombinationwelcomeiswelcomeofwel
comecombinationwelcomeofwelcomeJAVAwelcomeJAVAwelcomeand   cMY  DOG 2 is dead.we
lcomeand   cMY   DOG 1 is dead.<td>

</table>
welcomeCDollarwelcomeiswelcomeCDollarwelcomecombinationwelcomeiswelcomeofwelcome
combinationwelcomeofwelcomeJAVAwelcomeJAVAwelcomeand   cMY  DOG 2 is dead.welcom
eand   cMY   DOG 1 is dead.

threads1.cdollar


<CDollar>
<%

class Main
{
	public Main()
	{
		<SUPER>();
	}

	public void main()
	{
		//create the tree
		
	}
}

  public  class  threads1  <--- TH  
  
  {
  
  
  public  <Str> str;
  
  public  void <RUN>
  {
  
  for  (int  i=0;i<=10;i++)
  CDollar.out.println(""+str);
  
  
  }
  
 public void  CDOLLAR-Main( )
{

threads1   t   =  <NEW>    threads1();

t.str  =  "thread1";

t.<START>;   //start    first  thread

threads1   t1   =  <NEW>   threads1();

t1.str  =  "thread2";

t1.<START>; //   start   second   thread.

//here   after  the   thread1   get  executed    thread 2  is  executed....



}
  
  
  }
  
  


%>


?>
<table bgcolor=green>
<td>thread1thread1thread1thread1thread1thread1thread1thread1thread1thread1thread
1thread2thread2thread2thread2thread2thread2thread2thread2thread2thread2thread2<t
d>

</table>
thread1thread1thread1thread1thread1thread1thread1thread1thread1thread1thread1thr
ead2thread2thread2thread2thread2thread2thread2thread2thread2thread2thread2


WHILES.cdollar

<CDollar> 
 
<%
public class WHILES 
{ 
   public Shared void main(String  args[])  throws  <EXE>
{ 
int a=0; 
while (a <=10) 
{ 
a++; 
CDollar.out.println("value="+a); 
if ( a==9) continue; 
else break; 
} 


} 
} 

%>

?>

output
value=1


==================================================================================
CDOLLAR OUTPUT STATEMENT
----------------------------------------------
CDollar.out.println(" "+" ");
It is used for printing the output followed by line.
We had to add + operator to concatenate the outputs.....
String
------------
String is represented by <Str> notation.
a) <Str> <strname> = new <Str> ();
This statement is used to create an object...
b) <Str> <strname> = value;
But this Statement will not create an object...
but it stores the value...
the differences between
a) if ( s1==s2)
== means it is used to compare the values...
b) if s1.EQ(s2)
EQ means EQUALS is used to compare objects..

CDOLLAR COLLECTIONS
------------------------------------
Why we use collections in our software development?
Because for various projects we will use various kinds of
datastructures that's why collections are focused.

Q: What are the Important concepts of Software Development?

ARRAYLIST
----------------
SYNTAX:
------------
<AList> <Type> arraylistobjectname = new <AList><Type>();
But type may be Object, int, Double,String,etc.
Why we focus Arraylist ?
Since ArrayList involves Powerful insertion and search mechanism when
compared to array.
So we focus it.
Some built in functions available in ArrayList they are add and remove.
syntax : arraylistobjectname.add(<datatype>);
syntax: arraylistobjectname.remove(<datatype>);
How did you iterate the ArrayList?
<WR> syntax means Iterator; this is the shortest syntax of Iterator.
<WR> iteratorname = <CollectionOBJECT>.record();

LinkedList
----------
<LList> <Type> arraylistobjectname <NEW> <LList><Type>
But type may be Object, int, Double,String,etc.
As according to collection concepts , built in functions are Designed for
LinkedList they are add and remove.
syntax : Linkedlistobjectname.add(<datatype>);
syntax: Linkedlistobjectname.remove(<datatype>);
syntax : Linkedlistobjectname.addFirst(<datatype>);
syntax: Linkedlistobjectname.removeFirst(<datatype>);
syntax : Linkedlistobjectname.addLast(<datatype>);
syntax: Linkedlistobjectname.removeLast(<datatype>);
Actually when you study about Datastructures of LinkedList
and here we Designed the LinkedList using the LinkedList code
as mentioned in above that is LinkedList.c$. And add more functions...
and we use CDollar Generics...
What is the function of LinkedList? Why we use LinkedList?
In ArrayList You can't insert element in to the middle
or first or last so LinkedList is focused....
LinkedList is a Good example of Train....

VECTOR
------------
Vector also has the same Datastructures of ArrayList;
but why we focus? . So vector is simillar to Arraylist.
So we can mention in short notation as VList.
but Vector is synchronized and ArrayList is not Synchronized.
Vector use Enumerator and Iterator but ArrayList use only Iterator.
<VList> <VectorObject> = <NEW> <VList> ();
<VectorObject>.addE(elements);
but vector used add functions
<VectorObject>.first(); => Represent First Element...
<VectorObject>.last(); => Represent Last Element...
<VectorObject>.removeAll(elements); => It is used to remove all elements..
<VectorObject>.removeAt(elements); => remove at Particular position
<VectorObject>.remove(object); => remove the first occurance of the given element
<VectorObject>.remove(index); => Remove by Index or position.


=========================================================================
More about COLLECTIONS
---------------------------------------------
SET
------
So Set is represented in Cdollar as <S>
Syntax:
-----------
<S> Objectname = new <S>();
Difference between Set and List?
List allow duplicates but Set did not allow duplicates...
Set did not allow insertion at middle.
For listing the elements in Ascending or descending order
we had to use TreeSet.
TREESET
------------
Treeset represent a collection that uses Tree datastructure for storage
Items in the collections are stored in Ascending or descending order.
<TS> objectname = new <TS>();
objectname.add(elements);
Operators conditions and loops
--------------------------------------------------
Operators
---------
+ => ADD
++=> Increment
- => Substract
--=> Substract
* => Mulitply
/ = Division
~ => bitwise unary not operator
NOT (!) => flips true values to false and false values to true.
>>, >>>, and << => IT is used to shift all the bits of a number left
or right
a Specified number of places...
Other Operators
----------------
AND => And operator
OR => OR operator
?: => value =condition ? value1 : value2 (similar to if then else)
== => compare two values...
= => Assignment operators
EQ => Compare two objects
Relational Operators
--------------------
> >= => Greater than , Greater than equals.
< <= => Less than , Less than equal
NOTEQ => Equals and not equals
NotEQ simillar to !=

CONDITIONS
----------
IF Syntax:
------------
if <condition> statements;
IF then else Syntax:
----------------------
if <condition> statements else statements1
if <condition> statements1 else if condition1 statement2 .... and soon.
SWITCH Statements:
-------------------
switch (expression)
{
case value1 :
statement1;
[break]
................
case valuen:
statementn;
[break]
-----
default:
default_statement;
}
Explanation:
------------
If the expression is equals value1
statement1 will be executed.
if you use break it comes out of the loop
otherwise it continue to execute next statement.
The default value at the end is optional. It can be included if there are other values that can be held in
your variable but that you haven't checked for elsewhere in the switch statement.
THE WHILE LOOP
-----------------------------
while (<condition> )
{
< Statements block>
}
Note: if the condition is true the block get executed.
otherwise the loop will be continued.
THE DO --- WHILE LOOP
-----------------------------
do
{
< Statements block>
}
while( <conditon> )
Note: if the condition is true the block get executed.
and it is tested at the end of the loop, but not at the
beginning. The loop will be continued until it satisfies the condition.
biggest reason to be use the do - while loop is that
when you need the body of the loop to be run atleast once.
FOR LOOP
--------
for ( identifier=value; cond1; iterator operators)
{
< Block statements >
}
For -EACH Statement
----------------------
for ( variable : collection)
statement;
for eg)
If you add integers (1 to 3) to arraylist
and if you wish to copy and store it in an integer variable
so that you can print the values that is copied from
arraylist.
Then follow this method of for each statements...
for ( int a : ar)
{
CDollar.out.println("value="+a);
}
Output:
-----------
value=1
value =2
value =3
CONTINUE and Break
---------------------------------
Break means it break out of loop
and continue means
it will continue to execute the statements;
for eg)
Program :WHILE LOOP with continue and break if statement...
--------------------------------------------------------------------------
<CDollar>
<IMPORT>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
CDollar.out.println("value="+a);
if ( a==9) continue;
// if you remove this if --else statements it will print all the
values..
else break;
}
}
}
%>
?>
Output:
-------
Wed Aug 19 10:09:23 GMT+00:00 2015*
CDollar: value=1

DATATYPES and OVERLOADING and OVERRIDING CONCEPTS, INNER CLASS
---------------------------------------------------------------------------------------
DATATYPES of CDollar are
-------------------------------
int -> accept only int value
float -> accept float value=>eg) 1.5f
boolean => true or false
character => accept character value
byte -> 1 byte
short -> 2 bytes
long-> 8 bytes
double-> for eg) 1.2121233232E9 => Accept double value
ARRAY => It is used to store values and had fixed size.
ARRAY
-------
SYNTAX:
<Datatype> Arrayname ARRAY [index]
int a ARRAY[1000]; => has 1000 locations to store values...
for two dimension ARRAY
int a[100] ARRAY[100]=> 100 *100 => has 10000 locations to store values
OTHER KEYWORDS IN CDOLLAR
--------------------------------------------------
AND -> AND operator
NOT -> NOT operator
# -> NOTEQUALS
RUN -> Runnable used in thread
TH-> Thread
<EXE> -> Exception
Friends -> Frend function
INNER and OUTER CLASS
-----------------------------------------
Inner class are nested inside outer class even if the fields
declared as private members.
<CDollar>
<IMPORT>
<%
class Outer {
private int privInt = 10;
public void createInnerClass() {
Inner inClass = <NEW> Inner(); //creating innerclass object and calling method
access.
inClass.access();
}
class Inner { // Inner class
public void access() {
CDollar.out.println("The outer classs privInt is " + privInt);
}
}
}
%>
OVERLOADING AND OVERRIDING functions
-------------------------------------------
OVERLOADING
------------
A functions with same name but different signature is called
as Overloading concept.
public void display(int i , String j) {}
=> If you pass int and string values from main program it will call
this function.
ABC a = <NEW> ABC(10,"ewew");
public void display(int i, int j) {}
ABC a = <NEW> ABC(10,20);
=> If you pass int and int values it will call this function.
OVERRIDING
-----------
A function with same name and same signature
will cause overriding....
Overriding can be avoided by using super() keyword.
in another class.
<CDollar>
<IMPORT>
<%
class abc
{
void display(String s)
{
CDollar.out.println("We learn C , Dotnet ,and ,CDollar");
}
}
class abcd <--- abc
{
void display(String s)
{
<SUPER>(s); // if super keyword is added we had to pass arguments in
super keyword.
CDollar.out.println("We learn C , Dotnet ,and ,JDollar");
}
}
%>
Note: this will cause overriding
and it can be avoided by using super () keyword.

OTHER ATTRACTIVE SYMBOLS in CDOLLAR
-------------------------------------------
--> => implements
<-- => extends
==================================================================================

UNIT 2
-------
FILE,Other collection concepts,Advanced Concepts of CDollar,Exception and
Error,Garbage collection
==================================================================================

Advanced Topics in FILE
-----------------------------
<BUFFINPUTSTREAM> =>you can use <MARK> and <RESET> keyword
to move backward in a buffered input stream.
<DOUTPUTSTREAM> =>
which can be used to write the stream or to do other operations on the stream.
IT USES <WRITEBYTES> TO Write into file.
<DINPUTSTREAM > => USED TO READ STRING FROM
THE FILE. It Uses <READBYTES> TO READ FROM A FILE.
<BREADER> =>Buffered reader uses <READLINE> to read a line from a
file.
<BWRITER> => Buffered writer uses <WRITELINE> to write a line from a
file.
<INPUTREADER> =>
The InputReader is intended to wrap an InputStream, thereby turning the byte based input stream into a
character based Reader.
<FILE> => used fort creating reading ,Appending, and writing string to a file.
Note: Character files are read and written using <FileWriter> and <FileReader>. Writing Streams of
character is best suited using FileWriter.
FileReader
----------
FileReader assumes that default character encoding and default byte-buffer size are appropriate.
FileReader reads character stream.
<FILESREADER>
FileWriter
----------
FileWriter assumes that default character encoding and default byte-buffer size are appropriate.
<FILESWRITER>
OUTPUTWRITER
<OUTPUTWRITER>
The OutputWriter is intended to wrap an OutputStream, thereby turning the byte based output stream
into a character based Writer.
Better than all this random Access file is the best use....
So file concepts are over. SO we ask developers to concenterate on
RandomAccess file....
OTHER COLLECTIONS CONCEPTS
---------------------------------------------------
<M> => map MEANS IT CONTAINS KEYS AND VALUE PAIRS...
HashSet
-------------
SYNTAX:
<HSET> <hashsetname> = <NEW> <HSET>();
HASHMAP
----------------
SYNTAX:
<HMAP> <HASHMAPNAME> = <NEW> <HMAP>();
<HASHMAPNAME>.PUT(key,valuepairs);
<HASHMAPNAME>.GETKEY(index);
<HMAP> mp = <NEW> <HMAP>();
mp .PUT(1, 234);
CDollar.out.println(""+mp.GETKEY(1));
HASHTABLE
----------------
SYNTAX:
<HTABLE> <HASHTABLENAME> = <NEW> <HTABLE>();
<HASHTABLENAME>.PUT(key,valuepairs);
<HASHTABLENAME>.GETKEY(index);
<HTABLE> mp = <NEW> <HTABLE>();
mp.PUT(1, 234);
CDollar.out.println(""+mp.GETKEY(0));
// This elements can be retrieved by using GETKEY().
note: hash determines a order in which elements are
stored in the hash; SO it will display according
to hash stored order.

ADVANCED CONCEPTS of CDOLLAR
----------------------------------------------------------
GENERIC STACK
-----------------------------
<GS> (we will see later)
ITERATOR
----------------
Iterator iterate about collection
in the forward direction and not in backward direction.
and it will iterate record wise from the List or collection.
<WR> it = collectionobj.record();
where collection obj may be list,arraylsit, and so on.
for EG)
<WR> it = ar.record(); //iterate arraylist.
while(it.<HAS>) // if it has more elements from arraylist
{
<OBJECT> el = it.<NEXT>;
//<OBJECT> is the object..
//<NEXT> is used to list next element from the collection
CDollar.out.println(" data= "+el);
//print the elements
}
Listiterator:
-------------
Normally Iterator will not move backward directions
by using iterator. It can be done by using Listiterator.
<LR> <listiterateobject> = Object.<LISTLR>();
eg)
<LR> it1 = ar.<LISTLR>; // iterate the arraylist in backward direction
if you use <PREVIOUS> keyword
while(it1.<HASP>) // if the iterator has more elements
{
<OBJECT> el1 = it1.<PREVIOUS>;
//move to previous record from arraylist
CDollar.out.println(" data1= "+el1);
//print the object
}
ARRAYSSORT
---------------------
<A>.<SORT>(arrayname);
SO if you want to sort an array you
must use the keyword <A>.<SORT>(ar);
That means the give array is sorted in ascending order and
store it in array
ARRAYBINARYSEARCH
-----------------
<A>.<BinarySearch>(arrayname,position)
This will search the array in binarysearch wise...
according to the given position.
Exception and ERROR
-----------------------------------
Exception is a abnormal condition that arise during
the code sequence at run time.
What are the two Types of Exception?
Checked and Unchecked Exception.
Exception that arise during the run time are called as
Unchecked exception.
Thrown exception are refer to the checked exception.
Unchecked Exception
--------------------
<Arithmetic> -> Arithmetic exception
<ArrayIndex> -> ArrayIndex outof bound exception
<ArrayStore> -> Assignment to an array of an incompactible type.
<IndexOut> -> Index out of boud exception
<NegativeArraySize> -> Array Created with a negative array size.
<NullPointer> -> Null pointer exception
<NumberFormat> -> invalid conversion of string to numeric format.
typing or giving data string as input in integer datatype.
<SecurityException> -> Attempt to violate security
<StringIndex> ->Attempt to acess index ouside the bounds of a string.
Checked Exception
-----------------
<ClassNotFound> -.> class not found
<CloneNotFound>-> Clone keyword is absent
<IllegalAcess> -> Access to a class is denied.
<Instanation>-> Attempt to create an object of abstract class or friendly functions
<Interrupted>=> One thread has interrupted by another thread.
<NoSuchField> => A request field doesnot exist
<NoSuchMethod>=> Request emthod doesnot exist.
<TRY> -> try in C/JAVA
<CATCH> -> catch in c/java
<Finally> -> final in c/java
SYNTAX:
-------------
<TRY>
{
< Executable good statements>
}
<CATCH> (<EXE> e)
{
CDollar.out.println(""+e);
}
<Finally>
{
<Final block statements>
}
Explanation:
-------------------
When ever the Exception is true statements inside a try
block is executed; otherwise
statements inside a catch block is executed.
Exception occurs or not
final block get executed..
FINAL in CDOLLAR
--------------------------
UnShared keyword means final in CDollar
eg)
UnShared int i=9;
// if a variable is declared as final
that value can't be changed.
eg)
UnShared class abc
{
.......
}
if the class is declared as UnShared it can't
be overridden.
so if the method is declared as UnShared
such method can't be overriden by another class method.
GARBAGE COLLECTION
-------------------
<RECYCLE> => Garbage colection
eg) if you allocate elements a=9;
but doesnot use in the program so such object
are garbage collected by using <RECYCLE> keyword.

THREADS
--------------
A thread is a path of execution that run on CPU
and process is a collection of thread that share a same virtual
memory.

SYNCHRONIZED:
------------
If multiple clients want to access the shared resource
synchronization provide the way for the multiple clients
not for the specific one.
BIG Program for Synchronization
----------------------------------

<CDollar>







<%
  
 class threads

{

    public void  CDOLLAR-Main( ) 

    {

        My thread1 = <NEW> My("thread1: ");

        My thread2 = <NEW> My("thread2: ");

        thread1.<START>;

        thread2.<START>;

        boolean thread1IsAlive = true;

        boolean thread2IsAlive = true;

        do {

           if (thread1IsAlive AND NOTthread1.isAlive()) {

               thread1IsAlive = false;

              CDollar.out.println("MY   DOG 1 is dead.");

           }

           if (thread2IsAlive AND NOTthread2.isAlive()) {

               thread2IsAlive = false;

               CDollar.out.println("MY  DOG 2 is dead.");

           }

        } while(thread1IsAlive || thread2IsAlive);

    }

}

 

class My <--- TH

{

Shared <Str> message[] ={ "CDollar", "is", "combination", "of", "JAVA", "and   c"};

 

    public My(<Str> id)

    {

        <SUPER>(id);

    }

 

    public void <RUN>

    {

        SyncOut.displayList("welcome",message);

    }

 

    void randomWait()

    {

        <TRY> {

         <SLEEP>((long)(3000*Math.random()));

        } <CATCH> (<EXE> x) {

           CDollar.out.println("Interrupted!");

        }

    }

}

 

class SyncOut

{

public Shared synchronized void  displayList(<Str> name,<Str> list[])

{

for(int i=0;i<list.length;++i) {

My t = (My) TH.currentTH();

t.randomWait();

CDollar.out.println(name+list[i]);

}

}

} 


  
  


%>


?>

Output:
welcomeCDollarwelcomeiswelcomecombinationwelcomeofwelcomeJAVAwelcomeand   cMY
DOG 1 is dead.welcomeCDollarwelcomeiswelcomecombinationwelcomeofwelcomeJAVAwelco
meand   cMY  DOG 2 is dead.

WAIT
--------
It WAITS indefinitely for another thread of execution until it receives notify
or notify all message.
<WAIT>
NOTIFY AND NOTIFYALL
----------------------------------------
<NOTIFY> ->
The keyword process waits for a single thread waiting on a
object monitor.
ALL ->
The keyword process waits for a multiple thread waiting on a
object monitor.
JOIN
--------
join() method
This Process join with another thread after another thread finishes the
execution.
eg) Thread t1 => Wait for 100 seconds
and Thread t2 => will execute after Thread t1 complets the execution.
This is the meaning of join process in Thread.

CDOLLAR ADVANCED CONCEPTS
--------------------------------
STACK
---------
Stack means lastin first out.
A stack is a container of objects that are inserted and removed according to the last-in first-out (LIFO)
principle.
In the pushdown stacks only two operations are allowed: push the item into the stack, and pop the item
out of the stack.
<STACK> s= <NEW> <STACK>();
s.<PUSH>(100); // PUSH operator to push the elements into stack
s.<PUSH>(2000);
s.<POP>;
CDollar.out.println(""+s);
Output:
[100]
Priority Queue:
---------------------
Many applications require that we process items having keys in order, but not necessarily in full sorted
order and not necessarily all at once.
Often, we collect a set of items, then process the one with the largest key, then perhaps collect more
items, then process the one with the current largest key,
and so forth. An appropriate data type in such an environment supports two operations:
remove the maximum and insert. Such a data type is called a priority queue.
<PRIORITYQUEUE> q = <NEW> <PRIORITYQUEUE>();
q.add(1000);
q.add(544);
q.add(66);
q.add(667888);
CDollar.out.println(""+q);
Output:
-------
[66, 1000, 544, 667888]
Destructor:
----------
Destructor means object is going to be destroyed.
~
{
CDollar.out.println("object is deleted");
// this means object is going to be destroyed.
}
where ~ is the Destructor

Operator Overloading in CDollar
------------------------------------------------
This means we can overload the operators
like + - = / > < >= <=
Compare CompareTo
public Shared void operator *(int s1 ,int s2)
{
s3=s1 * s2;
CDollar.out.println(""+s3);
}
public  Shared void  LIB( )
{
operator *(10,10);
// You are passing * Multiply Operator in the main Program
operator *(200,10000);
}
GENERICS
---------------
GENRICS means which is used to Pass Type as argument as class
for example if you want to pass String , int, float datatypes at the
same time and if you use display method to display the value of any
datatype
so Generic is most useful in that case.
<CDollar>
<%
public class GEN<T>
{
T t;
T display(T t1)
{
t=t1;
return(t);
}
public  Shared void  LIB( )
{
GEN <Integer> i = <NEW> GEN<Integer> ();
CDollar.out.println(""+ i.display(10));
}
}
%>
?>

==================================================================================

UNIT-3 :CDOLLAR GRAPHICS and NETWORKING
==================================================================================

CDOLLAR GRAPHICS always focus on GWT Graphics and GUI. GWT
is a heavy weighted toolkit.
CDollar Graphics can be done by extending Graphics class.
This will create a frame for that.
GWT graphics can be drawn using <PAINT> method.
Program-1
----------

<CDollar>
<USE> <CJAVA>.awt.*;
<%
   class  abcde <--- Graphics 

{
 public void  CDOLLAR-Main( )
{
abr  a  = <NEW> abr();





 a.<SIZE>(500,700);
     
     a.<FLOWLAYOUT>
 a.<VISIBLE=TRUE>
    

}


Shared  class abr  <--- abcde
{
<PAINT>

{
//Color  c  =  <NEW> Color();

for(int  i=0; i<=600;i++)
{

<DRAWTEXT>("CHOOSEN  CHOICE  is",400,500);
<SETCOLOUR>(COLOR=red);
<OVAL>(10+i,10+i,50+i,50+i);
<FILLOVAL>(70+i,90+i,140+i,100+i);
<SETCOLOUR>(COLOR=blue);
<OVAL>(190+i,10+i,90+i,30+i);
<RECT>(100+i,10+i,60+i,50+i);
<SETCOLOUR>(COLOR=cyan);
<FILLRECT>(100+i,10+i,60+i,50+i);
<ROUNDRECT>(190+i,10+i,60+i,50+i,15+i,15+i);
<SETCOLOUR>(COLOR=green);
<ARC>(10+i,20+i,150+i,190+i,160+i,60+i);
<FILLARC>(230+i,15+i,150+i,200+i,150+i,75+i);

if ( i== 300)  i=i-1;
}


}

}
}
%>


?>

Program-2:
----------
Draw a house using CDollar

HOUSE.cdollar

<CDollar>


<USE> <CJAVA>.awt.*;




<%
   class  HOUSE  <--- <GRAPHICS>

{

public void  CDOLLAR-Main( )
{

houseparts a  = <NEW> houseparts();

 a.<SIZE>(500,700);
     
     a.<FLOWLAYOUT>
 a.<VISIBLE=TRUE>

}



Shared class houseparts  <--- HOUSE
{
 <PAINT> 
    { 
        background(g); 
        house (g); 
        roof1 (g); 
        roof2 (g); 
        windows (g); 
        framing (g); 
        extras (g); 
        text (g); 
    } 
      
    public void background(<DRAW> g) 
    { 
     
        
        <SETCOLOUR>(COLOR=black);
         
  
  
        <FILLOVAL> (15,35,170,55); 
        <FILLOVAL> (20,20,160,50); 
        <FILLOVAL> (350,50,170,55); 
        <FILLOVAL> (355,35,160,50);
        
  
        
       
        <SETCOLOUR>(COLOR=cyan);  
        <FILLOVAL> (650,035,120,120); 
        <SETCOLOUR>(COLOR=green);  
       <ARC>(10,20,180,190,160,60);
  <FILLARC>(230,15,150,200,150,75);
    } 
      
    public void house (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=yellow);    
        <FILLRECT> (100,250,400,200); 
        <FILLRECT> (499,320,200,130); 
        <SETCOLOUR>(COLOR=green);      
        <FILLRECT> (160,150,60,90); 
        <FILLRECT> (245,380,110,70); 
        <FILLRECT> (508,350,180,100); 
        <SETCOLOUR>(COLOR=yellow);  
       <FILLOVAL> (282,412,10,10); 
        <FILLOVAL> (307,412,10,10); 
          
    } 
      
    public void roof1 (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=pink);  
        int x[] = {98,300,501}; 
        int y[] = {250,130,250}; 
        <FILLPOLYGON>(x,y,3); 
    } 
      
    public void roof2 (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=orange); 
        int x[] = {499,499,700}; 
        int y[] = {320,249,320}; 
        <FILLPOLYGON>(x,y,3); 
    } 
      
      
    public void windows (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=white);  
       <FILLOVAL>(521,350,68,31); 
        <FILLOVAL> (606,350,68,31); 
        <FILLRECT> (121,261,78,78); 
        <FILLRECT> (121,361,78,78); 
        <FILLRECT> (401,261,78,78); 
        <FILLRECT> (401,361,78,78); 
        <FILLRECT> (241,261,118,78);    
       <SETCOLOUR>(COLOR=white);
        <FILLRECT> (125,265,70,70); 
        <FILLRECT> (125,365,70,70); 
        <FILLRECT>(405,265,70,70); 
        <FILLRECT> (405,365,70,70); 
        <FILLRECT> (245,265,110,70); 
        <FILLOVAL> (525,353,60,25); 
        <FILLOVAL> (610,353,60,25); 
    } 
      
    public void framing (<DRAW> g) 
    { 
         <SETCOLOUR>(COLOR=black);  
          
        <FILLRECT> (298,380,2,70); 
        <FILLRECT> (508,382,180,2); 
        <FILLRECT> (508,417,180,2); 
        <SETCOLOUR>(COLOR=white);  
        <FILLRECT> (157,265,5,70); 
        <FILLRECT> (157,365,5,70); 
        <FILLRECT> (437,265,5,70); 
        <FILLRECT> (438,365,5,70); 
        <FILLRECT> (297,265,5,70); 
        <FILLRECT> (125,298,70,5); 
        <FILLRECT> (125,398,70,5); 
        <FILLRECT> (405,298,70,5); 
        <FILLRECT> (405,398,70,5); 
        <FILLRECT> (245,298,110,5); 
        <FILLRECT> (245,375,110,5);  
        <FILLRECT> (240,375,5,75); 
        <FILLRECT> (352,375,5,75); 
        <FILLRECT> (508,345,180,5); 
        <FILLRECT> (503,345,5,105); 
        <FILLRECT> (688,345,5,105); 
    } 
      
    public void extras (<DRAW> g) 
    { 
        <SETCOLOUR>(COLOR=orange);  
        <FILLOVAL> (160,105,35,45); 
        <FILLOVAL> (170,95,35,45); 
        <FILLOVAL> (160,85,35,45); 
        <FILLOVAL> (170,35,35,45); 
        <FILLOVAL> (160,25,35,45); 
        <FILLOVAL> (170,15,35,45); 
        <SETCOLOUR>(COLOR=orange);  
        <FILLRECT> (508,450,180,150); 
        <FILLRECT> (245,450,107,50); 
        <FILLRECT> (274,500,50,40); 
        <FILLRECT> (274,520,250,45); 
        } 
          
    public void text (<DRAW> g) 
    {    
        <SETCOLOUR>(COLOR=orange);              
                <DRAWTEXT>("House portrait by: wilmix jemin",390,70); 
    } 

    }
    
    
    

}


%>


?>


PROGRAM-3
----------
if you select radio or listbox or combobox it should display items
in text box.
//Graphics using GWT and GWT components are heavy weighted

<CDollar>
<USE> <CJAVA>.awt.*;

<%


class GUI1  <--- <GRAPHICS>  --> <HEAR>


{

Shared <RADIO> r <GWT=6>(); 
Shared <TEXTFIELD> l3 <GWT=3> (); 
Shared <CHECKBOX> l5 <GWT=5> ("YES",false,r);
 Shared  <CHECKBOX> l51 <GWT=5> ("NO",false,r);
 
Shared  <LISTBOX> lb <GWT=7>();
 Shared  <COMBOBOX> cb <GWT=8>();

 Shared  <Str>  s= "";
<ITEMSTATECHANGED>
{

if  (ie.<ITEMSELECTABLE> == l5)

l3.<VALUE>("YES");


if  (ie.<ITEMSELECTABLE> == l51)

l3.<VALUE>("NO");


if  (ie.<ITEMSELECTABLE> == cb)
l3.<VALUE>(((<COMBOBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);


if  (ie.<ITEMSELECTABLE> == lb)

l3.<VALUE>(((<LISTBOX>) ie.<ITEMSELECTABLE>).<SELECTITEM>);

s=l3.<ASSIGN>();

}

   public void  CDOLLAR-Main( ) {
   
  abrpaint g  =<NEW>  abrpaint();

  <IMAGE>
     //GUI1  g  = <NEW> GUI1();
    <LABEL> l1 <GWT=1> ("CDollar  GUI  Programming");  
<BUTTON> l2 <GWT=2> ("CDollar  GUI  Programming");  
//<TEXTFIELD> l3 <GWT=3> ();  
<TEXTAREA> l4 <GWT=4> (12,40);  
//<CHECKBOX> l5 <GWT=5> ("Yes"); 

l5.<SOUND>(g);
//<CHECKBOX> l51 <GWT=5> ("NO");


l51.<SOUND>(g);

       l3.<VALUE>("<THIS> is a textbox");
       l4.<APPEND>("Number of columns in this textarea: " +   l4.<COLS>);

       //the add() method of the Frame class is
       //used to add components to the frame
       g.add(l1);
      g.add(l2);
      g.add(l3);
       g.add(l4);
   g.add(l5);
    g.add(l51);
     
lb.add("CDOLLAR"); 
lb.add("JAVA");
lb.add("JDOLLAR");
lb.add("C");
lb.add("MAC");
 g.add(lb);lb.<SOUND>(g);
 
cb.add("CDOLLAR"); 
cb.add("JAVA");
cb.add("JDOLLAR");
cb.add("C");
cb.add("MAC");
 
    g.add(cb);cb.<SOUND>(g);
       
       
       
     g.<SIZE>(500,700); 
     g.<FLOWLAYOUT>
      g.<VISIBLE=TRUE>
     
     
  }
  
  
  Shared  class abrpaint  <--- GUI1
{
<PAINT>

{

<DRAWTEXT>("CHOOSEN  CHOICE  is"+s,400,500);

<RECT>(20,10,100,60);

}

}


}


%>


?>




CDOLLAR Networking
-------------------------------------
N/w are essential to our life. Intenet is born due to networking and
A method of Client -server communications
gives like a house - to house interaction.

CLIENT SERVER PROGRAM
--------------------------------
<CDollar>

<PACK>  MYOS
{
    <CLASS> MYOs
    {
public FLOAT CDollar-MAIN(){


<CLIENT>("localhost","1099");

<SERVER>("1099");


          
               
     %>

?>

==================================================================================
UNIT -4:Advanced Concepts
==================================================================================
Let us consider a Program to print using WHILE LOOP
Program -1
----------
<CDollar>
<IMPORT>
<%
public class WHILE
{
public  Shared void  LIB( )
{
int a=0;
while (a <=10)
{
a++;
CDollar.out.println("value="+a);
}
}
}
%>
?>
Compilation:
CDollarc WHILE.cdollar
Output:
(note: at One time compilation you will get this output in windows platform)
********************************************************************
Tue Mar 01 1
3:30:08 IST 2016*JAS: Error:
***************************************************
******************************************
WHILE Tue Mar 01 13:30:09 IST 2016 CDollar:
Output: value=1value=2value=3value=4value=5value=6value=7value=8value=9value=10va
lue=11Error: value=1value=2value=3value=4value=5value=6value=7value=8value=9valu
e=10value=11
========================================
What is Pointers?

Variables that hold memory address are called pointers.
Why we mainly use Pointers?
Pointers reduces the length and complexity of the program,
They increase the execution speed.
It holds the memmory addres..
SYNTAX of CDollar Pointers:
---------------------------------
 
 {*} <pointername> Pointers (<VALUE>);  
BUCKET
-------
Bucket are used to store key,value data, and Generated Random number
where datatype may be string ,object ,etc.
SYNTAX:
----------
Bucket<DATATYPE> list = <NEW> Bucket<DATATYPE>(<DATATYPEVALUE>);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages
----------
Using Bucket you can also Retrieve the values stored n position.
Searching and Insertion is fast than other DTS.
Random Indexing is possible.
eg) If you store a duplicate value such Random key will be different.
It also used to add many values.
EXTEND
------
Extend class is used in CDollar since to provide multiple inheritence
about 100000000 classes . Extends class also list values in methods and
constructor values.
Extend means a Bucket contains List of class and it is also
Behave like Bucket. So it is also one of the Advanced concepts in CDollar.
SYNTAX:
--------
EXTEND <<DATATYPE>> list11 = <NEW> EXTEND <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Advantages:
It is also used to add many values
Indexing is possible
Value can also be list by index and behave like bucket.
It list only the class value and object value.
It is stateless.
PIPE:
-----
PIPE is used to maintain stateful state.
It is used for DataFlow in a Program. We can also add the values,
Constructor values of one class and other class and display it.
It also list the values from the Bucket.

SYNTAX:
-------
Pipe <<DATATYPE>> list11 = <NEW> Pipe <<DATATYPE>> (STRING);
list.KeyAdd(<DATATYPEVALUE>);
list.add(<DATATYPEVALUE>);
list.RandomAdd();
list.Display(list);
Why we Prefer CDollar for software Field?
Used in BILLS, Forms ,Reports,Charts, any software project , GRAPHICS to web etc.







==================================================================================

UNIT -5 :CDOLLAR CODING STANDARDS AND ADVANTAGES OVER OTHER
PROGRAMMING LANGUAGES
==================================================================================


Coding Standards of CDollar
------------------------------
<CDollar>
<IMPORT>
<USE> package;
<%
%>
?>
Note : <% and %> is used to write class and it's logic.
ALL Program should Start with <CDollar> means starting of a Program and
succeded by <IMPORT> 
to load all  CDollar packages and ?> Means End of the Program.
but  we  use  <USE>   to  load   the   particular   packages  and  we  save  the  memmory.
HIDE Unwanted code
--------------------
<------ program code ------>
MAIN Program:
-------------
public  Shared void  LIB( ) indicates MAIN Program
otherwise it will not run the Program
STATIC BLOCK
-------------
Shared means Static keyword.
Shared will be executed first after that Main program will
be executed.
Shared
{
}
{} => This curly braces are mostly used.
SOME OPERATOR KEYWORDS
-------------------------
AND => && in java
NOT => !
# => !=
NEW Keyword
---------------
NEW is used to create an instance in memmory.
Always concenterate on important keyword not need to
memmorize at all.
DATATYPES:
-----------
int , char, double , float are ordinary keywords of oops
Programming language like C/JAVA/C#/CDollar.
STRUCTURES:
-----------
Always use Structure DATATYPE to store your data in objects form
so that it will reduce the storage allocation in memmory.
for one object it takes only 1 byte of memmory for structures.
RECYCLE:
-------
Always use RECYCLE to make the unwanted object to be garbage collected.
//
----
If you want to describe something about your functions
use // . Don't use it unnessary at any way.
Special Characters
--------------------
@,$%,^,[] are not allowed in the CDOLLAR program
~
---
Use Destructor keyword to specify non CDollar resource deletion code to
be goes when you it..
Other Things
-------------
for loop , if statements, while loop, do while ,
for each, Switch statements, AutoBoxing , Generics , etc
are same.
Did CDollar support pointer?
-----------------------------------
YES.
private LinkedList nextNode =null;
consider this line ; This line creates a pointer to a class
LinkedList .
nextNode=new LinkedList(datum);
This statements are use to insert first data to Linkedlist
nextNode.add(datum) is used to insert many data....
Class Inheritance
-------------------
If the Class is using another class variable in that case
you had to use <--- "extends" backward arrows
and front arrows --> for implements..
Implements is used when you use friend function.

CDollar ADvantages over JAVA and other Programming Languages
----------------------------------------------------------------------------------
A) CDollar is the combination of JAVA , C/C++, and Advanced OOPS.
b) CDollar will only accept the shortest attractive syntax.
c) CDollar also used for construction of any datastructures.
d) CDollar helps the developers to provide inheritance by not using extends
keyword
and call the class in main program when use in linux.
e) CDOLLAR Solves diamond Problem with multiple Inheritance when used in linux.
f) It also supports friendly function, pointers , and structures.
g) CDollar support Virtual memmory and garbage collection.
h) It is efficient, fast and easy to understand, and it is a OOPS Technology.
i) CDollar is a High level language.
j) CDollar is highly portable language
k) Using CDollar you can create any datastructures as libraries and
use it in your Application program.
l) CDollar language is a structured and object programming language.
m) CDollar has OOPS concepts like JAVA.
n) CDollar have the concept of Packages,etc.
o) CDollar have the concept of constructor or destructor and had magic oops concepts.
p) It Support functions with Default Arguments
q) It Supports Exception handling
r) It Support Generic Programming
s) It have pointer and Nodes..
t) CDollar is much simpler oops concepts, which leads to faster development and less mental
overhead.
u) CDollar is almost always explicitly compiled
w) CDollar is easy to learn. CDollar was designed to be easy to use and is therefore easy to write,
compile, debug, and learn than other programming languages.
CDollar is object-oriented. This allows you to create modular programs and reusable code.
CDollar is platform-independent.
x) CDollar creates .wl  and  .exe  or  .dll   files   and  it  can be  used  with   CDollar  main  program   (CWE  EDitor  )   to  create  a  complete  software.
y) CDollar will compile and run at same time where other technology can't
do
z) CDollar is mainly used in complex programming , Billing the
goods,Graphics,etc
AA) CDollar is platform independant language
BB) CDollar is an interactive Technology.

Disadvantages of CDollar Technology
------------------------------------------------
a) CDollar doesn't concenterate mostly
on GUI but mostly on invention of new
datastructures,OOPS, Advanced OOPS..
b) CDollar doesnot focused on
cloud computing...
Note: SO CDOLLAR is a medium
programming language in IT   and  WRIT sector which
is mainly focused on security, datastructures,
,OOPS, Advanced OOPS in software development field only.

FAQS
------
A) A C Programmer or any oops developer can easily
study it....
Note:
CDollarv.2 ,CDollarv.1 ,CDollarv.3 is not a Version. Cdollarv.3 is a improved compiler.
CDollarv.3 ,CDC is a compiler and CDollarv.4 is a Translator and translate to
.wl files and
CDRUN is responsible for running the CDollar Program.


==================================================================================

UNIT -6 :CDOLLAR MAIN  Program Syntax  AND ADVANCED   CONCEPTS  PROGRAM.
(.cdollar-CWE)

==================================================================================

Syntax:

<CDollar>

<PACK> <nAMESPACE>
<%
    <CLASS> <CLASSNAME>
    {
        public FLOAT CDollar-MAIN()
        {
            
<!  CDOLLAR  LOGIC!>              
               
     

%>

?>





BAG
=====
Bag is the extension of LinkedHashmap and it is the fastest
datastructures than Dictionary.

SYNTAX:
=======


Bag object = new Bag();
object .put(key,value);
Functions
getValues(key) => it is used to get the values for a particular key
get(key,loc) => it is used to get the value stored at a loc (indexing
purpose)
boolean containsValue(object Value) => To check the value present in bag or
not.
put(key,value) => it is used to add key and value in Bag
remove(key ,value) => It is used to remove key and value.



TreeList
========

TreeList simillar to Bucket but store items in tree format.

TreeList list = new TreeList ("BUCKETS");
list.KeyAdd(KEY);
list.add(VALUE1);
list.RandomAdd(RANDOMNO);
list.DisplayO(list,0);


MASK
====
It is the extension of Tree Structure and it can store many values
using mask object and we can also retrieve the values stored in mask.
Mask m = new Mask(<DATATYPE>);
m.add(multiple values);
m.getR(Loc); => Get the values stored in right position
m.getL(LOC) => Get the values stored in left position


HEAP:
====


Creates a tree , puts the data into tree in a fairly balanced way and displays
the tree's size and data in a tree by performing an inorder traversal.
Heap hob = new Heap(<datatype>);
hob.add(datum);
hob = new Heap(key,value1,value2);



Bucktist
==========



Bucktist is simillar to Bucket but it is used to addd two values with one
key.
Bucktist l = null;
l= new Bucktist(key,value1,value2);


WICKET
=======
Wicket is used to store multiple values using same object with
4 values per key.

Syntax:

Wicket list12;
list12=new Wicket(key,v1,v2,v3,v4);
list12.Display();
list12.Display(list12,location);




EXAMPLE -1: BAG

<CDollar>

<PACK> MyP
<%
    <CLASS> Programs
    {
        public FLOAT CDollar-MAIN()
        {
            
        Bag  b <NEW> Bag();

b.PUT(1,34);
b.PUT(2,444);

<PRINTLN>(""+b);
              
               
     

%>

?>


EXAMPLE:2  : CDOLARARRAYS
==========

<CDollar>

<USE> <CDOLLARS>.util;

<PACK> MyP
{
    <CLASS> Programs
    {
         
        public FLOAT CDollar-MAIN()
        {
            

<AList>  ar <NEW> <AList> ();
 for  (int  i=0;i<=100000;i++)
 ar.add(i);

 
 
 
 <CDOLLARARRAYS> list1 <NEW>  <CDOLLARARRAYS>("ANIMALS ");
        list1.add("1 horse");
 list1.add("2 pig");
 list1.add("3 cow");
 list1.add("4 goat");
 list1.add("5 chicken");
 
 list1.add("6 ostrich");
 list1.add(ar.StringConvert());
 list1.Display();

 
              
               
     %>

?>


EXAMPLE-3: CREATE  AN  BOOTLOADER   Using  CDOLLAR

 <CDollar>

<PACK>  MYOS
{
    <CLASS> MYOs
    {
public FLOAT CDollar-MAIN(){


<PRINTLN>("HelloWorld  for  booting  MYOS");

          
               
     %>

?>




EXAMPE-4: POINTERS


<CDollar>
<PACK> MyP
{
    <CLASS> Programs
    {
        public FLOAT CDollar-MAIN()
        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers (s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
              
                
               
     %>

?>


EXAMPLE-5: DICTIONARY


<CDollar>
<USE> System.Collections.Generic;

<PACK> MyP
{
    <CLASS> Programs
    {
         
        public FLOAT CDollar-MAIN()
        {
            

 Dictionary<string, string> openWith  <NEW>  Dictionary<string, string>();
openWith.Add("txt", "notepad.exe");
openWith.Add("bmp", "paint.exe");
openWith.Add("dib", "paint.exe");
openWith.Add("rtf", "wordpad.exe"); 
              
             
               
     %>

?>



Example-6: EXTEND



<CDollar>

<IMPORT>



<PACK> MyP

<%
    <CLASS> Programs
    <%
        public FLOAT CDollar-MAIN()

        {
 
 
 EXTEND list <NEW> EXTEND("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);
                    
<PRINTLN>(""+list.DisplayO(list,1));

 
%>


?>


EXAMPLE-7: HEAP





<CDollar>


<PACK> MyP
{
      <CLASS> Programs
    {
         public FLOAT CDollar-MAIN()
        {
 

 Heap root <NEW> Heap("wilmix");
 
 for (int i = 0; i <= 10; i = i + 1)
 {
 root.add("item " + i);
 }
                 
 <PRINTLN>(root.size() );
 root.printTree();

          
               
     %>

?>



Example-8: LArray


<CDollar>
<USE> <CDOLLARS>.util;

<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT CDollar-MAIN()
        {
 
 LArray root <NEW> LArray("root");
 
 <AList>  ar <NEW>  <AList>();
 
 
 for  (int  i=0;i<=1000;i++)
 
 ar.add(i);
 
 root.add("wilmix");
 root.add("jemin");
 root.add("shalom");
 root.add("1010");
 root.add("101");
 root.add("201");
 root.add(ar.StringConvert());
 root.add("100000000");
 //print the tree's size and contents
 
 root.printTree();



          
               
     %>

?>


Example-9 : PIPE




<CDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
public FLOAT CDollar-MAIN()
        {
 

Pipe list  <NEW> Pipe("BUCKETS");
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                     
                     list.RandomAdd();    
                     
                     list.Display(list);

<PRINTLN>(""+list.DisplayO(list,1));

 
          
               
     %>

?>




EXAMPLE-10: TREELIST



<CDollar>

<PACK> MyP

{
    <CLASS> Programs
    {
        public FLOAT CDollar-MAIN()
        {
 


TreeList list  <NEW> TreeList ("BUCKETS");
 
 
 
 
 
 
      list.KeyAdd("1101");  
                    
                     list.add("jemin");
                    
                     
                     list.RandomAdd("1111");   

TreeList list2 <NEW> TreeList("BUCKETS");
 list2.KeyAdd("1102");  
                    
                     list2.add("rahul");
                    
                     
                     list2.RandomAdd("1112");
                     
                 


<PRINTLN>("DATA="+list.DisplayO(list,0));


<PRINTLN>("DATA="+list2.DisplayO(list2,0));

          
               
     %>

?>


Example-11 : MASK




<CDollar>
<USE>  <CDOLLARS>.util;


<PACK> My
{
    <CLASS> Programs
    {
           public FLOAT CDollar-MAIN()
        {
 

 MASK root <NEW> MASK("wilmix");
 
 for (int i = 0; i NOT= 10; i = i + 1)
 {
 root.add("item " + i);
 }
             
 
 
 
 
 root <NEW> MASK("root1",1211211,54441);
 
 root  <NEW> MASK("root2",121121,5444);
 root  <NEW> MASK("root5",99121888,"5");
 
 root  <NEW> MASK("root3",12112,544);
 
 root  <NEW> MASK("root4",1211,54);
 
 root  <NEW> MASK("root51",121,5);
 
 
 root.printTree();
 


          
               
     %>

?>





Example-12 : WICKET


<CDollar>


<PACK> MyPo
{
    <CLASS> Programs
    {
           public FLOAT CDollar-MAIN()
        {
 Wicket  list12;
 list12 <NEW> Wicket(1000,10002,43433,4343,5555451);
 list12 <NEW> Wicket(10001,100021,434331,4343,5555452);
 list12 <NEW> Wicket(10002,100022,434332,4343,5555453);
 list12 <NEW> Wicket(10003,100023,434333,4343,5555454);
 list12 <NEW> Wicket(10004,100024,434334,4343,5555455);
 list12 <NEW> Wicket(10005,100025,434335,4343,5555456);
 
 
 list12.Display(list12);
 
 <PRINTLN>("DATA="+list12.DisplayO(list12,0));
                 
          
               
     %>

?>


Example-13 : STRUCTURE


<CDollar>
<PACK> MyPoi
{
    <CLASS> Programs
    {
          public FLOAT CDollar-MAIN()

        {
            

 <Str>  s="dsdds";
 
 {*} l Pointers(s);  
 
l.add(s);
 
 for (int i = 0; i NOT= l.size(); i = i + 1)
 {
 
 <OBJECT> obj=l.GETKEY(i);
 <PRINTLN>(obj);
 
 
 
 }
 
 
 
 
 <STRUCTURE>  list <NEW> <STRUCTURE> (l.GETKEY(0));
 
 for (int i11 = 0; i11 NOT= list.size(); i11 = i11 + 1)
 {
 
 
 
 <OBJECT>  el=list.ret(i11);
 

 
 <PRINTLN>("SNO= "+el);

                }
              
            
               
     %>

?>




Example-14 : BUCKETIST


<CDollar>


<PACK> MyP
{
    <CLASS> Programs
    {
          public FLOAT CDollar-MAIN()
        {
 




Bucketist  bp    <NEW>  Bucketist("wilmix");

bp    <NEW>  Bucketist(1,222,434);
bp   <NEW>  Bucketist(1,222,434);


bp.Display(bp);


<PRINTLN>("DATA="+bp.DisplayO(bp,1));
          
               
     %>

?>


CDOLLAR  PROGRAM  With OPerator  Overloading

<CDollar>
<PACK> Area
{
   <CLASS> Rectangle
   {
      private double length;   // Length of a Rectangle
      private double breadth;  // Breadth of a Rectangle
      private double height;   // Height of a Rectangle

      public double GETKEYVolume()
      {
         return length * breadth * height;
      }
      
      public void <SET>Length( double len )
      {
         length = len;
      }

      public void <SET>Breadth( double bre )
      {
         breadth = bre;
      }

      public void <SET>Height( double hei )
      {
         height = hei;
      }
      
      // Overload + operator to add two Rectangle objects.
      public Shared Rectangle operator+ (Rectangle b, Rectangle c)
      {
         Rectangle Rectangle <NEW>Rectangle();
         Rectangle.length = b.length + c.length;
         Rectangle.breadth = b.breadth + c.breadth;
         Rectangle.height = b.height + c.height;
         return Rectangle;
      }

   }

   <CLASS> Tester
   {
     public FLOAT CDollar-MAIN()
      {
         Rectangle rectangle1 <NEW>Rectangle();   // Declare rectangle1 of type Rectangle
         Rectangle rectangle2 <NEW>Rectangle();   // Declare rectangle2 of type Rectangle
         Rectangle rectangle3 <NEW>Rectangle();   // Declare rectangle3 of type Rectangle
         double volume = 0.0;    // Store the volume of a Rectangle here

         // Rectangle 1 specification
         rectangle1.<SET>Length(6.0);
         rectangle1.<SET>Breadth(7.0);
         rectangle1.<SET>Height(5.0);

         // Rectangle 2 specification
         rectangle2.<SET>Length(12.0);
         rectangle2.<SET>Breadth(13.0);
         rectangle2.<SET>Height(10.0);

         // volume of Rectangle 1
         volume = rectangle1.GETKEYVolume();
         <PRINTLN>("Volume of rectangle1 : {0}", volume);

         // volume of Rectangle 2
         volume = rectangle2.GETKEYVolume();
         <PRINTLN>("Volume of rectangle2 : {0}", volume);

         // Add two object as follows:
         rectangle3 = rectangle1 + rectangle2;

         // volume of Rectangle 3
         volume = rectangle3.GETKEYVolume();
         <PRINTLN>("Volume of rectangle3 : {0}", volume);
     
      }
   }
}


Note:  This  CDOLLAR - Tutorial- EXERCISES   is  a  Practical  Exercises    for CDollar  Programmers  we  can  use  CDOLLAR-LIB DLL     in  CDollar   main  program


==================================================================================
UNIT:7  :    CDollar   Security,CDOLLAR  with  WDBA DB
==================================================================================




CDOLLAR with  WDBA

<CDollar>
<USE> CDollar.WDBA; //use   cdolla.wdba packages
<USE> <CDOLLARS>.util; /use cdollar.util packages
<USE> <CDOLLARS>.lang;
<USE> WDBA;
<PACK> WDBAexample
{
    public <CLASS> example1
    {
        
        Shared void Main()

        {
string g = WDBASQL.WDBASQLS("datastores", "USEDATABASE", "dbpwds", "C:\\Programs\\WNOSQL\\WNOSQLProgramfiles\\WNOSQL-cod"); 
//  declare   directory  of  .wdba files

           


            string t = WDBASQL.WDBASQLS("dbuser", "dbpwds", 1, "wilmix78", "wilmix78", 1, 5, g);

 // supply username  and  password

            string s1 = "SelectAll from columns 0 to 20 , 1 to 1 ?= XXX By X f(x) : {0,1,2}: {3,4,5} :{2,4}";
//selectall  columns  from 0 to  20 for  row  and  cols   1,1  respectively.
  
            string s11 = "RIGHTJOIN from student 0 to 1 , 1 to 4 ?= emp For X f(x) : {0,1,2,3,4,5,6,7,8,9,10,11} : {0,1,2,3,4,5,6,7,8,9,10,11} : {0}";
//perform   right  join  between  query  student  and  emp.
            
            <PRINTLN>(""+SQL.WDBAQUERY(  s1,  t));
//print  selectall from  columns table
            <PRINTLN>("" + SQL.WDBAQUERY(s11, t));
//print  right join  query.
        }
    }
}



a)SCREENSHOTS   OF  CDOLLAR  Project Structure

 


b)  CDOLLAR  _CWE  EDITOR

 





================================================================

CJAVA


<CJAVA>

<USE> package;
<PACK> package
{
  
    <CLASS> classname
   {

   
      public void main()
      {
        
<! code  logic !>

      }
   }
}


Example-1
========

At  first   add TreeExample.dll  to  properties  file

and  compile   the  program using CDollarcc Tree.cjava

<CJAVA>

<USE> Tree;
<PACK> Tree
{
  
    <CLASS> Tree
   {

   
      public void main()
      {
        
TreeExample.call();// call  the  api  of CDollar.


      }
   }
}


note:  CDollar  is  part    of  GDollar  programming Language

================================================================================== 
                                      THE    END   OF   GDollar-CDollar   PDF    TUTORIAL
==================================================================================
